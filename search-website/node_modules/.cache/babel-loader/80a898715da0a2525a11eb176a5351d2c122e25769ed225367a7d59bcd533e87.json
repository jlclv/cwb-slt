{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { IndexDocumentsBatch } from \"./indexDocumentsBatch\";\nimport EventEmitter from \"events\";\nimport { createSpan } from \"./tracing\";\nimport { delay } from \"./serviceUtils\";\nimport { getRandomIntegerInclusive } from \"./serviceUtils\";\n/**\n * Default Batch Size\n */\nexport const DEFAULT_BATCH_SIZE = 512;\n/**\n * Default window flush interval\n */\nexport const DEFAULT_FLUSH_WINDOW = 60000;\n/**\n * Default number of times to retry.\n */\nexport const DEFAULT_RETRY_COUNT = 3;\n/**\n * Default retry delay.\n */\nexport const DEFAULT_RETRY_DELAY = 800;\n/**\n * Default Max Delay between retries.\n */\nexport const DEFAULT_MAX_RETRY_DELAY = 60000;\n/**\n * Class used to perform buffered operations against a search index,\n * including adding, updating, and removing them.\n */\nexport class SearchIndexingBufferedSender {\n  /**\n   * Creates a new instance of SearchIndexingBufferedSender.\n   *\n   * @param client - Search Client used to call the underlying IndexBatch operations.\n   * @param options - Options to modify auto flush.\n   *\n   */\n  constructor(client, documentKeyRetriever, options = {}) {\n    var _a, _b, _c, _d, _e, _f;\n    /**\n     * Event emitter/publisher used in the Buffered Sender\n     */\n    this.emitter = new EventEmitter();\n    this.client = client;\n    this.documentKeyRetriever = documentKeyRetriever;\n    // General Configuration properties\n    this.autoFlush = (_a = options.autoFlush) !== null && _a !== void 0 ? _a : true;\n    this.initialBatchActionCount = (_b = options.initialBatchActionCount) !== null && _b !== void 0 ? _b : DEFAULT_BATCH_SIZE;\n    this.flushWindowInMs = (_c = options.flushWindowInMs) !== null && _c !== void 0 ? _c : DEFAULT_FLUSH_WINDOW;\n    // Retry specific configuration properties\n    this.throttlingDelayInMs = (_d = options.throttlingDelayInMs) !== null && _d !== void 0 ? _d : DEFAULT_FLUSH_WINDOW;\n    this.maxRetriesPerAction = (_e = options.maxRetriesPerAction) !== null && _e !== void 0 ? _e : DEFAULT_RETRY_COUNT;\n    this.maxThrottlingDelayInMs = (_f = options.maxThrottlingDelayInMs) !== null && _f !== void 0 ? _f : DEFAULT_MAX_RETRY_DELAY;\n    this.batchObject = new IndexDocumentsBatch();\n    if (this.autoFlush) {\n      const interval = setInterval(() => this.flush(), this.flushWindowInMs);\n      interval === null || interval === void 0 ? void 0 : interval.unref();\n      this.cleanupTimer = () => {\n        clearInterval(interval);\n      };\n    }\n  }\n  /**\n   * Uploads the documents/Adds the documents to the upload queue.\n   *\n   * @param documents - Documents to be uploaded.\n   * @param options - Upload options.\n   */\n  async uploadDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexingBufferedSender-uploadDocuments\", options);\n    try {\n      this.batchObject.upload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"upload\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Merges the documents/Adds the documents to the merge queue.\n   *\n   * @param documents - Documents to be merged.\n   * @param options - Upload options.\n   */\n  async mergeDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexingBufferedSender-mergeDocuments\", options);\n    try {\n      this.batchObject.merge(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"merge\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Merges/Uploads the documents/Adds the documents to the merge/upload queue.\n   *\n   * @param documents - Documents to be merged/uploaded.\n   * @param options - Upload options.\n   */\n  async mergeOrUploadDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexingBufferedSender-mergeOrUploadDocuments\", options);\n    try {\n      this.batchObject.mergeOrUpload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"mergeOrUpload\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes the documents/Adds the documents to the delete queue.\n   *\n   * @param documents - Documents to be deleted.\n   * @param options - Upload options.\n   */\n  async deleteDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexingBufferedSender-deleteDocuments\", options);\n    try {\n      this.batchObject.delete(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"delete\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Flushes the queue manually.\n   *\n   * @param options - Flush options.\n   */\n  async flush(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexingBufferedSender-flush\", options);\n    try {\n      if (this.batchObject.actions.length > 0) {\n        return this.internalFlush(true, updatedOptions);\n      }\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * If using autoFlush: true, call this to cleanup the autoflush timer.\n   */\n  async dispose() {\n    if (this.batchObject.actions.length > 0) {\n      await this.internalFlush(true);\n    }\n    if (this.cleanupTimer) {\n      this.cleanupTimer();\n    }\n  }\n  on(event, listener) {\n    this.emitter.on(event, listener);\n  }\n  off(event, listener) {\n    this.emitter.removeListener(event, listener);\n  }\n  isBatchReady() {\n    return this.batchObject.actions.length >= this.initialBatchActionCount;\n  }\n  async internalFlush(force, options = {}) {\n    if (force || this.autoFlush && this.isBatchReady()) {\n      // Split it\n      const actions = this.batchObject.actions;\n      this.batchObject = new IndexDocumentsBatch();\n      while (actions.length > 0) {\n        const actionsToSend = actions.splice(0, this.initialBatchActionCount);\n        const {\n          batchToSubmit,\n          submitLater\n        } = this.pruneActions(actionsToSend);\n        actions.unshift(...submitLater);\n        await this.submitDocuments(batchToSubmit, options);\n      }\n    }\n  }\n  pruneActions(batch) {\n    const hashSet = new Set();\n    const resultBatch = [];\n    const pruned = [];\n    for (const document of batch) {\n      const key = this.documentKeyRetriever(document);\n      if (hashSet.has(key)) {\n        pruned.push(document);\n      } else {\n        hashSet.add(key);\n        resultBatch.push(document);\n      }\n    }\n    return {\n      batchToSubmit: resultBatch,\n      submitLater: pruned\n    };\n  }\n  async submitDocuments(actionsToSend, options, retryAttempt = 1) {\n    try {\n      for (const action of actionsToSend) {\n        this.emitter.emit(\"beforeDocumentSent\", action);\n      }\n      const result = await this.client.indexDocuments(new IndexDocumentsBatch(actionsToSend), options);\n      // raise success event\n      this.emitter.emit(\"batchSucceeded\", result);\n    } catch (e) {\n      if (e.statusCode && e.statusCode === 413 && actionsToSend.length > 1) {\n        // Cut the payload size to half\n        const splitActionsArray = [actionsToSend.slice(0, actionsToSend.length / 2), actionsToSend.slice(actionsToSend.length / 2, actionsToSend.length)];\n        this.initialBatchActionCount = splitActionsArray[0].length; // So, we do not want 413 happening again and again\n        for (const actions of splitActionsArray) {\n          await this.submitDocuments(actions, options);\n        }\n      } else if (this.isRetryAbleError(e) && retryAttempt <= this.maxRetriesPerAction) {\n        // Exponentially increase the delay each time\n        const exponentialDelay = this.throttlingDelayInMs * Math.pow(2, retryAttempt);\n        // Don't let the delay exceed the maximum\n        const clampedExponentialDelay = Math.min(this.maxThrottlingDelayInMs, exponentialDelay);\n        // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n        // that retries across multiple clients don't occur simultaneously.\n        const delayWithJitter = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n        await delay(delayWithJitter);\n        await this.submitDocuments(actionsToSend, options, retryAttempt + 1);\n      } else {\n        this.emitter.emit(\"batchFailed\", e);\n        throw e;\n      }\n    }\n  }\n  isRetryAbleError(e) {\n    return e.statusCode && (e.statusCode === 422 || e.statusCode === 409 || e.statusCode === 503);\n  }\n}","map":{"version":3,"names":["IndexDocumentsBatch","EventEmitter","createSpan","delay","getRandomIntegerInclusive","DEFAULT_BATCH_SIZE","DEFAULT_FLUSH_WINDOW","DEFAULT_RETRY_COUNT","DEFAULT_RETRY_DELAY","DEFAULT_MAX_RETRY_DELAY","SearchIndexingBufferedSender","constructor","client","documentKeyRetriever","options","emitter","autoFlush","_a","initialBatchActionCount","_b","flushWindowInMs","_c","throttlingDelayInMs","_d","maxRetriesPerAction","_e","maxThrottlingDelayInMs","_f","batchObject","interval","setInterval","flush","unref","cleanupTimer","clearInterval","uploadDocuments","documents","span","updatedOptions","upload","emit","action","internalFlush","e","setStatus","status","error","message","end","mergeDocuments","merge","mergeOrUploadDocuments","mergeOrUpload","deleteDocuments","delete","actions","length","dispose","on","event","listener","off","removeListener","isBatchReady","force","actionsToSend","splice","batchToSubmit","submitLater","pruneActions","unshift","submitDocuments","batch","hashSet","Set","resultBatch","pruned","document","key","has","push","add","retryAttempt","result","indexDocuments","statusCode","splitActionsArray","slice","isRetryAbleError","exponentialDelay","Math","pow","clampedExponentialDelay","min","delayWithJitter"],"sources":["C:\\Users\\julia\\Desktop\\cwb-slt\\search-website\\node_modules\\@azure\\search-documents\\src\\searchIndexingBufferedSender.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { IndexDocumentsBatch } from \"./indexDocumentsBatch\";\nimport {\n  IndexDocumentsAction,\n  IndexDocumentsOptions,\n  SearchIndexingBufferedSenderDeleteDocumentsOptions,\n  SearchIndexingBufferedSenderFlushDocumentsOptions,\n  SearchIndexingBufferedSenderMergeDocumentsOptions,\n  SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions,\n  SearchIndexingBufferedSenderOptions,\n  SearchIndexingBufferedSenderUploadDocumentsOptions,\n} from \"./indexModels\";\nimport { IndexDocumentsResult } from \"./generated/data/models\";\nimport { OperationOptions } from \"@azure/core-client\";\nimport EventEmitter from \"events\";\nimport { createSpan } from \"./tracing\";\nimport { delay } from \"./serviceUtils\";\nimport { getRandomIntegerInclusive } from \"./serviceUtils\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\n\n/**\n * Index Documents Client\n */\nexport interface IndexDocumentsClient<TModel extends object> {\n  /**\n   * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)\n   * for the given set of documents.\n   *\n   * @param batch - An array of actions to perform on the index.\n   * @param options - Additional options.\n   */\n  indexDocuments(\n    batch: IndexDocumentsBatch<TModel>,\n    options: IndexDocumentsOptions\n  ): Promise<IndexDocumentsResult>;\n}\n\n/**\n * Default Batch Size\n */\nexport const DEFAULT_BATCH_SIZE: number = 512;\n/**\n * Default window flush interval\n */\nexport const DEFAULT_FLUSH_WINDOW: number = 60000;\n/**\n * Default number of times to retry.\n */\nexport const DEFAULT_RETRY_COUNT: number = 3;\n/**\n * Default retry delay.\n */\nexport const DEFAULT_RETRY_DELAY: number = 800;\n/**\n * Default Max Delay between retries.\n */\nexport const DEFAULT_MAX_RETRY_DELAY: number = 60000;\n\n/**\n * Class used to perform buffered operations against a search index,\n * including adding, updating, and removing them.\n */\nexport class SearchIndexingBufferedSender<TModel extends object> {\n  /**\n   * Search Client used to call the underlying IndexBatch operations.\n   */\n  private client: IndexDocumentsClient<TModel>;\n  /**\n   * Indicates if autoFlush is enabled.\n   */\n  private autoFlush: boolean;\n  /**\n   * Interval between flushes (in milliseconds).\n   */\n  private flushWindowInMs: number;\n  /**\n   * Delay between retries\n   */\n  private throttlingDelayInMs: number;\n  /**\n   * Maximum number of Retries\n   */\n  private maxRetriesPerAction: number;\n  /**\n   * Max Delay between retries\n   */\n  private maxThrottlingDelayInMs: number;\n  /**\n   * Size of the batch.\n   */\n  private initialBatchActionCount: number;\n  /**\n   * Batch object used to complete the service call.\n   */\n  private batchObject: IndexDocumentsBatch<TModel>;\n  /**\n   * Clean up for the timer\n   */\n  private cleanupTimer?: () => void;\n  /**\n   * Event emitter/publisher used in the Buffered Sender\n   */\n  private readonly emitter = new EventEmitter();\n  /**\n   * Method to retrieve the document key\n   */\n  private documentKeyRetriever: (document: TModel) => string;\n\n  /**\n   * Creates a new instance of SearchIndexingBufferedSender.\n   *\n   * @param client - Search Client used to call the underlying IndexBatch operations.\n   * @param options - Options to modify auto flush.\n   *\n   */\n  constructor(\n    client: IndexDocumentsClient<TModel>,\n    documentKeyRetriever: (document: TModel) => string,\n    options: SearchIndexingBufferedSenderOptions = {}\n  ) {\n    this.client = client;\n    this.documentKeyRetriever = documentKeyRetriever;\n    // General Configuration properties\n    this.autoFlush = options.autoFlush ?? true;\n    this.initialBatchActionCount = options.initialBatchActionCount ?? DEFAULT_BATCH_SIZE;\n    this.flushWindowInMs = options.flushWindowInMs ?? DEFAULT_FLUSH_WINDOW;\n    // Retry specific configuration properties\n    this.throttlingDelayInMs = options.throttlingDelayInMs ?? DEFAULT_FLUSH_WINDOW;\n    this.maxRetriesPerAction = options.maxRetriesPerAction ?? DEFAULT_RETRY_COUNT;\n    this.maxThrottlingDelayInMs = options.maxThrottlingDelayInMs ?? DEFAULT_MAX_RETRY_DELAY;\n\n    this.batchObject = new IndexDocumentsBatch<TModel>();\n    if (this.autoFlush) {\n      const interval = setInterval(() => this.flush(), this.flushWindowInMs);\n      interval?.unref();\n      this.cleanupTimer = () => {\n        clearInterval(interval);\n      };\n    }\n  }\n\n  /**\n   * Uploads the documents/Adds the documents to the upload queue.\n   *\n   * @param documents - Documents to be uploaded.\n   * @param options - Upload options.\n   */\n  public async uploadDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderUploadDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-uploadDocuments\",\n      options\n    );\n    try {\n      this.batchObject.upload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"upload\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Merges the documents/Adds the documents to the merge queue.\n   *\n   * @param documents - Documents to be merged.\n   * @param options - Upload options.\n   */\n  public async mergeDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderMergeDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-mergeDocuments\",\n      options\n    );\n    try {\n      this.batchObject.merge(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"merge\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Merges/Uploads the documents/Adds the documents to the merge/upload queue.\n   *\n   * @param documents - Documents to be merged/uploaded.\n   * @param options - Upload options.\n   */\n  public async mergeOrUploadDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-mergeOrUploadDocuments\",\n      options\n    );\n    try {\n      this.batchObject.mergeOrUpload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"mergeOrUpload\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes the documents/Adds the documents to the delete queue.\n   *\n   * @param documents - Documents to be deleted.\n   * @param options - Upload options.\n   */\n  public async deleteDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderDeleteDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-deleteDocuments\",\n      options\n    );\n    try {\n      this.batchObject.delete(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"delete\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Flushes the queue manually.\n   *\n   * @param options - Flush options.\n   */\n  public async flush(\n    options: SearchIndexingBufferedSenderFlushDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexingBufferedSender-flush\", options);\n    try {\n      if (this.batchObject.actions.length > 0) {\n        return this.internalFlush(true, updatedOptions);\n      }\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * If using autoFlush: true, call this to cleanup the autoflush timer.\n   */\n  public async dispose(): Promise<void> {\n    if (this.batchObject.actions.length > 0) {\n      await this.internalFlush(true);\n    }\n    if (this.cleanupTimer) {\n      this.cleanupTimer();\n    }\n  }\n\n  /**\n   * Attach Batch Added Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(\n    event: \"batchAdded\",\n    listener: (e: { action: string; documents: TModel[] }) => void\n  ): void;\n  /**\n   * Attach Batch Sent Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"beforeDocumentSent\", listener: (e: IndexDocumentsAction<TModel>) => void): void;\n  /**\n   * Attach Batch Succeeded Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchSucceeded\", listener: (e: IndexDocumentsResult) => void): void;\n  /**\n   * Attach Batch Failed Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchFailed\", listener: (e: RestError) => void): void;\n  public on(\n    event: \"batchAdded\" | \"beforeDocumentSent\" | \"batchSucceeded\" | \"batchFailed\" | \"batchResizing\",\n    listener: (e: any) => void\n  ): void {\n    this.emitter.on(event, listener);\n  }\n\n  /**\n   * Detach Batch Added Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(\n    event: \"batchAdded\",\n    listener: (e: { action: string; documents: TModel[] }) => void\n  ): void;\n  /**\n   * Detach Batch Sent Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(\n    event: \"beforeDocumentSent\",\n    listener: (e: IndexDocumentsAction<TModel>) => void\n  ): void;\n  /**\n   * Detach Batch Succeeded Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchSucceeded\", listener: (e: IndexDocumentsResult) => void): void;\n  /**\n   * Detach Batch Failed Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchFailed\", listener: (e: RestError) => void): void;\n  public off(\n    event: \"batchAdded\" | \"beforeDocumentSent\" | \"batchSucceeded\" | \"batchFailed\",\n    listener: (e: any) => void\n  ): void {\n    this.emitter.removeListener(event, listener);\n  }\n\n  private isBatchReady(): boolean {\n    return this.batchObject.actions.length >= this.initialBatchActionCount;\n  }\n\n  private async internalFlush(force: boolean, options: OperationOptions = {}): Promise<void> {\n    if (force || (this.autoFlush && this.isBatchReady())) {\n      // Split it\n      const actions: IndexDocumentsAction<TModel>[] = this.batchObject.actions;\n      this.batchObject = new IndexDocumentsBatch<TModel>();\n      while (actions.length > 0) {\n        const actionsToSend = actions.splice(0, this.initialBatchActionCount);\n        const { batchToSubmit, submitLater } = this.pruneActions(actionsToSend);\n        actions.unshift(...submitLater);\n        await this.submitDocuments(batchToSubmit, options);\n      }\n    }\n  }\n\n  private pruneActions(batch: IndexDocumentsAction<TModel>[]): {\n    batchToSubmit: IndexDocumentsAction<TModel>[];\n    submitLater: IndexDocumentsAction<TModel>[];\n  } {\n    const hashSet: Set<string> = new Set<string>();\n    const resultBatch: IndexDocumentsAction<TModel>[] = [];\n    const pruned: IndexDocumentsAction<TModel>[] = [];\n\n    for (const document of batch) {\n      const key = this.documentKeyRetriever(document as unknown as TModel);\n      if (hashSet.has(key)) {\n        pruned.push(document);\n      } else {\n        hashSet.add(key);\n        resultBatch.push(document);\n      }\n    }\n    return { batchToSubmit: resultBatch, submitLater: pruned };\n  }\n\n  private async submitDocuments(\n    actionsToSend: IndexDocumentsAction<TModel>[],\n    options: OperationOptions,\n    retryAttempt: number = 1\n  ): Promise<void> {\n    try {\n      for (const action of actionsToSend) {\n        this.emitter.emit(\"beforeDocumentSent\", action);\n      }\n      const result = await this.client.indexDocuments(\n        new IndexDocumentsBatch<TModel>(actionsToSend),\n        options\n      );\n      // raise success event\n      this.emitter.emit(\"batchSucceeded\", result);\n    } catch (e: any) {\n      if (e.statusCode && e.statusCode === 413 && actionsToSend.length > 1) {\n        // Cut the payload size to half\n        const splitActionsArray = [\n          actionsToSend.slice(0, actionsToSend.length / 2),\n          actionsToSend.slice(actionsToSend.length / 2, actionsToSend.length),\n        ];\n        this.initialBatchActionCount = splitActionsArray[0].length; // So, we do not want 413 happening again and again\n        for (const actions of splitActionsArray) {\n          await this.submitDocuments(actions, options);\n        }\n      } else if (this.isRetryAbleError(e) && retryAttempt <= this.maxRetriesPerAction) {\n        // Exponentially increase the delay each time\n        const exponentialDelay = this.throttlingDelayInMs * Math.pow(2, retryAttempt);\n        // Don't let the delay exceed the maximum\n        const clampedExponentialDelay = Math.min(this.maxThrottlingDelayInMs, exponentialDelay);\n        // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n        // that retries across multiple clients don't occur simultaneously.\n        const delayWithJitter =\n          clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n        await delay(delayWithJitter);\n        await this.submitDocuments(actionsToSend, options, retryAttempt + 1);\n      } else {\n        this.emitter.emit(\"batchFailed\", e);\n        throw e;\n      }\n    }\n  }\n\n  private isRetryAbleError(e: any): boolean {\n    return e.statusCode && (e.statusCode === 422 || e.statusCode === 409 || e.statusCode === 503);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}