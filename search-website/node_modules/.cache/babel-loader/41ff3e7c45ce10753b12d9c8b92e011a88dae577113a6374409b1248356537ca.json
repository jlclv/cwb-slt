{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __rest } from \"tslib\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { SearchClient as GeneratedClient } from \"./generated/data/searchClient\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { createSearchApiKeyCredentialPolicy } from \"./searchApiKeyCredentialPolicy\";\nimport { logger } from \"./logger\";\nimport { createSpan } from \"./tracing\";\nimport { deserialize, serialize } from \"./serialization\";\nimport { createOdataMetadataPolicy } from \"./odataMetadataPolicy\";\nimport { IndexDocumentsBatch } from \"./indexDocumentsBatch\";\nimport { decode, encode } from \"./base64\";\nimport * as utils from \"./serviceUtils\";\nimport { KnownSearchAudience } from \"./searchAudience\";\n/**\n * Class used to perform operations against a search index,\n * including querying documents in the index as well as\n * adding, updating, and removing them.\n */\nexport class SearchClient {\n  /**\n   * Creates an instance of SearchClient.\n   *\n   * Example usage:\n   * ```ts\n   * const { SearchClient, AzureKeyCredential } = require(\"@azure/search-documents\");\n   *\n   * const client = new SearchClient(\n   *   \"<endpoint>\",\n   *   \"<indexName>\",\n   *   new AzureKeyCredential(\"<Admin Key>\")\n   * );\n   * ```\n   *\n   * Optionally, the type of the model can be used to enable strong typing and type hints:\n   * ```ts\n   * type TModel = {\n   *   keyName: string;\n   *   field1?: string | null;\n   *   field2?: { anotherField?: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   ...\n   * );\n   * ```\n   *\n   * @param endpoint - The endpoint of the search service\n   * @param indexName - The name of the index\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Search client.\n   *\n   * @typeParam TModel - An optional type that represents the documents stored in\n   * the search index. For the best typing experience, all non-key fields should\n   * be marked optional and nullable, and the key property should have the\n   * non-nullable type `string`.\n   */\n  constructor(endpoint, indexName, credential, options = {}) {\n    var _a, _b;\n    /// Maintenance note: when updating supported API versions,\n    /// the ContinuationToken logic will need to be updated below.\n    /**\n     *  The service version to use when communicating with the service.\n     */\n    this.serviceVersion = utils.defaultServiceVersion;\n    /**\n     * The API version to use when communicating with the service.\n     * @deprecated use {@Link serviceVersion} instead\n     */\n    this.apiVersion = utils.defaultServiceVersion;\n    this.endpoint = endpoint;\n    this.indexName = indexName;\n    const internalClientPipelineOptions = Object.assign(Object.assign({}, options), {\n      loggingOptions: {\n        logger: logger.info,\n        additionalAllowedHeaderNames: [\"elapsed-time\", \"Location\", \"OData-MaxVersion\", \"OData-Version\", \"Prefer\", \"throttle-reason\"]\n      }\n    });\n    this.serviceVersion = (_b = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : options.apiVersion) !== null && _b !== void 0 ? _b : utils.defaultServiceVersion;\n    this.apiVersion = this.serviceVersion;\n    this.client = new GeneratedClient(this.endpoint, this.indexName, this.serviceVersion, internalClientPipelineOptions);\n    if (isTokenCredential(credential)) {\n      const scope = options.audience ? `${options.audience}/.default` : `${KnownSearchAudience.AzurePublicCloud}/.default`;\n      this.client.pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential,\n        scopes: scope\n      }));\n    } else {\n      this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));\n    }\n    this.client.pipeline.addPolicy(createOdataMetadataPolicy(\"none\"));\n  }\n  /**\n   * Retrieves the number of documents in the index.\n   * @param options - Options to the count operation.\n   */\n  async getDocumentsCount(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-getDocumentsCount\", options);\n    try {\n      let documentsCount = 0;\n      await this.client.documents.count(Object.assign(Object.assign({}, updatedOptions), {\n        onResponse: (rawResponse, flatResponse) => {\n          documentsCount = Number(rawResponse.bodyAsText);\n          if (updatedOptions.onResponse) {\n            updatedOptions.onResponse(rawResponse, flatResponse);\n          }\n        }\n      }));\n      return documentsCount;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Based on a partial searchText from the user, return a list\n   * of potential completion strings based on a specified suggester.\n   * @param searchText - The search text on which to base autocomplete results.\n   * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.\n   * @param options - Options to the autocomplete operation.\n   * @example\n   * ```ts\n   * import {\n   *   AzureKeyCredential,\n   *   SearchClient,\n   *   SearchFieldArray,\n   * } from \"@azure/search-documents\";\n   *\n   * type TModel = {\n   *   key: string;\n   *   azure?: { sdk: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   \"endpoint.azure\",\n   *   \"indexName\",\n   *   new AzureKeyCredential(\"key\")\n   * );\n   *\n   * const searchFields: SearchFieldArray<TModel> = [\"azure/sdk\"];\n   *\n   * const autocompleteResult = await client.autocomplete(\n   *   \"searchText\",\n   *   \"suggesterName\",\n   *   { searchFields }\n   * );\n   * ```\n   */\n  async autocomplete(searchText, suggesterName, options = {}) {\n    const {\n        searchFields\n      } = options,\n      nonFieldOptions = __rest(options, [\"searchFields\"]);\n    const fullOptions = Object.assign({\n      searchText: searchText,\n      suggesterName: suggesterName,\n      searchFields: this.convertSearchFields(searchFields)\n    }, nonFieldOptions);\n    if (!fullOptions.searchText) {\n      throw new RangeError(\"searchText must be provided.\");\n    }\n    if (!fullOptions.suggesterName) {\n      throw new RangeError(\"suggesterName must be provided.\");\n    }\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-autocomplete\", options);\n    try {\n      const result = await this.client.documents.autocompletePost(fullOptions, updatedOptions);\n      return result;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  async searchDocuments(searchText, options = {}, nextPageParameters = {}) {\n    const {\n        searchFields,\n        select,\n        orderBy,\n        includeTotalCount,\n        vectorSearchOptions\n      } = options,\n      restOptions = __rest(options, [\"searchFields\", \"select\", \"orderBy\", \"includeTotalCount\", \"vectorSearchOptions\"]);\n    const semanticSearchOptions = restOptions.semanticSearchOptions;\n    delete restOptions.semanticSearchOptions;\n    const _a = semanticSearchOptions !== null && semanticSearchOptions !== void 0 ? semanticSearchOptions : {},\n      {\n        configurationName,\n        errorMode,\n        answers,\n        captions\n      } = _a,\n      restSemanticOptions = __rest(_a, [\"configurationName\", \"errorMode\", \"answers\", \"captions\"]);\n    const _b = vectorSearchOptions !== null && vectorSearchOptions !== void 0 ? vectorSearchOptions : {},\n      {\n        queries,\n        filterMode\n      } = _b,\n      restVectorOptions = __rest(_b, [\"queries\", \"filterMode\"]);\n    const fullOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, restSemanticOptions), restVectorOptions), restOptions), nextPageParameters), {\n      searchFields: this.convertSearchFields(searchFields),\n      select: this.convertSelect(select) || \"*\",\n      orderBy: this.convertOrderBy(orderBy),\n      includeTotalResultCount: includeTotalCount,\n      vectorQueries: queries === null || queries === void 0 ? void 0 : queries.map(this.convertVectorQuery.bind(this)),\n      answers: this.convertQueryAnswers(answers),\n      captions: this.convertCaptions(captions),\n      semanticErrorHandling: errorMode,\n      semanticConfigurationName: configurationName,\n      vectorFilterMode: filterMode\n    });\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-searchDocuments\", options);\n    try {\n      const result = await this.client.documents.searchPost(Object.assign(Object.assign({}, fullOptions), {\n        searchText: searchText\n      }), updatedOptions);\n      const {\n          results,\n          nextLink,\n          nextPageParameters: resultNextPageParameters,\n          semanticPartialResponseReason: semanticErrorReason,\n          semanticPartialResponseType: semanticSearchResultsType\n        } = result,\n        restResult = __rest(result, [\"results\", \"nextLink\", \"nextPageParameters\", \"semanticPartialResponseReason\", \"semanticPartialResponseType\"]);\n      const modifiedResults = utils.generatedSearchResultToPublicSearchResult(results);\n      const converted = Object.assign(Object.assign({}, restResult), {\n        results: modifiedResults,\n        semanticErrorReason: semanticErrorReason,\n        semanticSearchResultsType: semanticSearchResultsType,\n        continuationToken: this.encodeContinuationToken(nextLink, resultNextPageParameters)\n      });\n      return deserialize(converted);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  listSearchResultsPage(searchText, options = {}, settings = {}) {\n    return __asyncGenerator(this, arguments, function* listSearchResultsPage_1() {\n      let decodedContinuation = this.decodeContinuationToken(settings.continuationToken);\n      let result = yield __await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));\n      yield yield __await(result);\n      // Technically, we should also leverage nextLink, but the generated code\n      // doesn't support this yet.\n      while (result.continuationToken) {\n        decodedContinuation = this.decodeContinuationToken(result.continuationToken);\n        result = yield __await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));\n        yield yield __await(result);\n      }\n    });\n  }\n  listSearchResultsAll(firstPage, searchText, options = {}) {\n    return __asyncGenerator(this, arguments, function* listSearchResultsAll_1() {\n      var _a, e_1, _b, _c;\n      yield __await(yield* __asyncDelegator(__asyncValues(firstPage.results)));\n      if (firstPage.continuationToken) {\n        try {\n          for (var _d = true, _e = __asyncValues(this.listSearchResultsPage(searchText, options, {\n              continuationToken: firstPage.continuationToken\n            })), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n            _c = _f.value;\n            _d = false;\n            const page = _c;\n            yield __await(yield* __asyncDelegator(__asyncValues(page.results)));\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    });\n  }\n  listSearchResults(firstPage, searchText, options = {}) {\n    const iter = this.listSearchResultsAll(firstPage, searchText, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings = {}) => {\n        return this.listSearchResultsPage(searchText, options, settings);\n      }\n    };\n  }\n  /**\n   * Performs a search on the current index given\n   * the specified arguments.\n   * @param searchText - Text to search\n   * @param options - Options for the search operation.\n   * @example\n   * ```ts\n   * import {\n   *   AzureKeyCredential,\n   *   SearchClient,\n   *   SearchFieldArray,\n   * } from \"@azure/search-documents\";\n   *\n   * type TModel = {\n   *   key: string;\n   *   azure?: { sdk: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   \"endpoint.azure\",\n   *   \"indexName\",\n   *   new AzureKeyCredential(\"key\")\n   * );\n   *\n   * const select = [\"azure/sdk\"] as const;\n   * const searchFields: SearchFieldArray<TModel> = [\"azure/sdk\"];\n   *\n   * const searchResult = await client.search(\"searchText\", {\n   *   select,\n   *   searchFields,\n   * });\n   * ```\n   */\n  async search(searchText, options) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-search\", options);\n    try {\n      const pageResult = await this.searchDocuments(searchText, updatedOptions);\n      return Object.assign(Object.assign({}, pageResult), {\n        results: this.listSearchResults(pageResult, searchText, updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Returns a short list of suggestions based on the searchText\n   * and specified suggester.\n   * @param searchText - The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.\n   * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.\n   * @param options - Options for the suggest operation\n   * @example\n   * ```ts\n   * import {\n   *   AzureKeyCredential,\n   *   SearchClient,\n   *   SearchFieldArray,\n   * } from \"@azure/search-documents\";\n   *\n   * type TModel = {\n   *   key: string;\n   *   azure?: { sdk: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   \"endpoint.azure\",\n   *   \"indexName\",\n   *   new AzureKeyCredential(\"key\")\n   * );\n   *\n   * const select = [\"azure/sdk\"] as const;\n   * const searchFields: SearchFieldArray<TModel> = [\"azure/sdk\"];\n   *\n   * const suggestResult = await client.suggest(\"searchText\", \"suggesterName\", {\n   *   select,\n   *   searchFields,\n   * });\n   * ```\n   */\n  async suggest(searchText, suggesterName, options = {}) {\n    const {\n        select,\n        searchFields,\n        orderBy\n      } = options,\n      nonFieldOptions = __rest(options, [\"select\", \"searchFields\", \"orderBy\"]);\n    const fullOptions = Object.assign({\n      searchText: searchText,\n      suggesterName: suggesterName,\n      searchFields: this.convertSearchFields(searchFields),\n      select: this.convertSelect(select),\n      orderBy: this.convertOrderBy(orderBy)\n    }, nonFieldOptions);\n    if (!fullOptions.searchText) {\n      throw new RangeError(\"searchText must be provided.\");\n    }\n    if (!fullOptions.suggesterName) {\n      throw new RangeError(\"suggesterName must be provided.\");\n    }\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-suggest\", options);\n    try {\n      const result = await this.client.documents.suggestPost(fullOptions, updatedOptions);\n      const modifiedResult = utils.generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(result);\n      return deserialize(modifiedResult);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieve a particular document from the index by key.\n   * @param key - The primary key value of the document\n   * @param options - Additional options\n   */\n  async getDocument(key, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-getDocument\", options);\n    try {\n      const result = await this.client.documents.get(key, Object.assign(Object.assign({}, updatedOptions), {\n        selectedFields: updatedOptions.selectedFields\n      }));\n      return deserialize(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)\n   * for the given set of documents.\n   * This operation may partially succeed and not all document operations will\n   * be reflected in the index. If you would like to treat this as an exception,\n   * set the `throwOnAnyFailure` option to true.\n   * For more details about how merging works, see: https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents\n   * @param batch - An array of actions to perform on the index.\n   * @param options - Additional options.\n   */\n  async indexDocuments(\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  batch, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-indexDocuments\", options);\n    try {\n      let status = 0;\n      const result = await this.client.documents.index({\n        actions: serialize(batch.actions)\n      }, Object.assign(Object.assign({}, updatedOptions), {\n        onResponse: (rawResponse, flatResponse) => {\n          status = rawResponse.status;\n          if (updatedOptions.onResponse) {\n            updatedOptions.onResponse(rawResponse, flatResponse);\n          }\n        }\n      }));\n      if (options.throwOnAnyFailure && status === 207) {\n        throw result;\n      }\n      return result;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Upload an array of documents to the index.\n   * @param documents - The documents to upload.\n   * @param options - Additional options.\n   */\n  async uploadDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-uploadDocuments\", options);\n    const batch = new IndexDocumentsBatch();\n    batch.upload(documents);\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Update a set of documents in the index.\n   * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents\n   * @param documents - The updated documents.\n   * @param options - Additional options.\n   */\n  async mergeDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-mergeDocuments\", options);\n    const batch = new IndexDocumentsBatch();\n    batch.merge(documents);\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Update a set of documents in the index or upload them if they don't exist.\n   * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents\n   * @param documents - The updated documents.\n   * @param options - Additional options.\n   */\n  async mergeOrUploadDocuments(documents, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-mergeDocuments\", options);\n    const batch = new IndexDocumentsBatch();\n    batch.mergeOrUpload(documents);\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  async deleteDocuments(keyNameOrDocuments, keyValuesOrOptions, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchClient-deleteDocuments\", options);\n    const batch = new IndexDocumentsBatch();\n    if (typeof keyNameOrDocuments === \"string\") {\n      batch.delete(keyNameOrDocuments, keyValuesOrOptions);\n    } else {\n      batch.delete(keyNameOrDocuments);\n    }\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  encodeContinuationToken(nextLink, nextPageParameters) {\n    if (!nextLink || !nextPageParameters) {\n      return undefined;\n    }\n    const payload = JSON.stringify({\n      apiVersion: this.apiVersion,\n      nextLink,\n      nextPageParameters\n    });\n    return encode(payload);\n  }\n  decodeContinuationToken(token) {\n    if (!token) {\n      return undefined;\n    }\n    const decodedToken = decode(token);\n    try {\n      const result = JSON.parse(decodedToken);\n      if (result.apiVersion !== this.apiVersion) {\n        throw new RangeError(`Continuation token uses unsupported apiVersion \"${this.apiVersion}\"`);\n      }\n      return {\n        nextLink: result.nextLink,\n        nextPageParameters: result.nextPageParameters\n      };\n    } catch (e) {\n      throw new Error(`Corrupted or invalid continuation token: ${decodedToken}`);\n    }\n  }\n  convertSelect(select) {\n    if (select) {\n      return select.join(\",\");\n    }\n    return select;\n  }\n  convertVectorQueryFields(fields) {\n    if (fields) {\n      return fields.join(\",\");\n    }\n    return fields;\n  }\n  convertSearchFields(searchFields) {\n    if (searchFields) {\n      return searchFields.join(\",\");\n    }\n    return searchFields;\n  }\n  convertOrderBy(orderBy) {\n    if (orderBy) {\n      return orderBy.join(\",\");\n    }\n    return orderBy;\n  }\n  convertQueryAnswers(answers) {\n    if (!answers) {\n      return answers;\n    }\n    const config = [];\n    const {\n      answerType: output,\n      count,\n      threshold\n    } = answers;\n    if (count) {\n      config.push(`count-${count}`);\n    }\n    if (threshold) {\n      config.push(`threshold-${threshold}`);\n    }\n    if (config.length) {\n      return output + `|${config.join(\",\")}`;\n    }\n    return output;\n  }\n  convertCaptions(captions) {\n    if (!captions) {\n      return captions;\n    }\n    const config = [];\n    const {\n      captionType: output,\n      highlight\n    } = captions;\n    if (highlight !== undefined) {\n      config.push(`highlight-${highlight}`);\n    }\n    if (config.length) {\n      return output + `|${config.join(\",\")}`;\n    }\n    return output;\n  }\n  convertVectorQuery(vectorQuery) {\n    if (!vectorQuery) {\n      return vectorQuery;\n    }\n    return Object.assign(Object.assign({}, vectorQuery), {\n      fields: this.convertVectorQueryFields(vectorQuery === null || vectorQuery === void 0 ? void 0 : vectorQuery.fields)\n    });\n  }\n}","map":{"version":3,"names":["bearerTokenAuthenticationPolicy","SearchClient","GeneratedClient","isTokenCredential","createSearchApiKeyCredentialPolicy","logger","createSpan","deserialize","serialize","createOdataMetadataPolicy","IndexDocumentsBatch","decode","encode","utils","KnownSearchAudience","constructor","endpoint","indexName","credential","options","serviceVersion","defaultServiceVersion","apiVersion","internalClientPipelineOptions","Object","assign","loggingOptions","info","additionalAllowedHeaderNames","_b","_a","client","scope","audience","AzurePublicCloud","pipeline","addPolicy","scopes","getDocumentsCount","span","updatedOptions","documentsCount","documents","count","onResponse","rawResponse","flatResponse","Number","bodyAsText","e","setStatus","status","error","message","end","autocomplete","searchText","suggesterName","searchFields","nonFieldOptions","__rest","fullOptions","convertSearchFields","RangeError","result","autocompletePost","searchDocuments","nextPageParameters","select","orderBy","includeTotalCount","vectorSearchOptions","restOptions","semanticSearchOptions","configurationName","errorMode","answers","captions","restSemanticOptions","queries","filterMode","restVectorOptions","convertSelect","convertOrderBy","includeTotalResultCount","vectorQueries","map","convertVectorQuery","bind","convertQueryAnswers","convertCaptions","semanticErrorHandling","semanticConfigurationName","vectorFilterMode","searchPost","results","nextLink","resultNextPageParameters","semanticPartialResponseReason","semanticErrorReason","semanticPartialResponseType","semanticSearchResultsType","restResult","modifiedResults","generatedSearchResultToPublicSearchResult","converted","continuationToken","encodeContinuationToken","listSearchResultsPage","settings","decodedContinuation","decodeContinuationToken","__await","listSearchResultsAll","firstPage","__asyncDelegator","__asyncValues","_d","_e","_f","next","done","_c","value","page","listSearchResults","iter","Symbol","asyncIterator","byPage","search","pageResult","suggest","suggestPost","modifiedResult","generatedSuggestDocumentsResultToPublicSuggestDocumentsResult","getDocument","key","get","selectedFields","indexDocuments","batch","index","actions","throwOnAnyFailure","uploadDocuments","upload","mergeDocuments","merge","mergeOrUploadDocuments","mergeOrUpload","deleteDocuments","keyNameOrDocuments","keyValuesOrOptions","delete","undefined","payload","JSON","stringify","token","decodedToken","parse","Error","join","convertVectorQueryFields","fields","config","answerType","output","threshold","push","length","captionType","highlight","vectorQuery"],"sources":["C:\\Users\\julia\\Desktop\\cwb-slt\\search-website\\node_modules\\@azure\\search-documents\\src\\searchClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport { InternalClientPipelineOptions } from \"@azure/core-client\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { SearchClient as GeneratedClient } from \"./generated/data/searchClient\";\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { createSearchApiKeyCredentialPolicy } from \"./searchApiKeyCredentialPolicy\";\nimport { logger } from \"./logger\";\nimport {\n  AutocompleteRequest,\n  AutocompleteResult,\n  IndexDocumentsResult,\n  KnownSemanticErrorReason,\n  KnownSemanticSearchResultsType,\n  SuggestRequest,\n  SearchRequest as GeneratedSearchRequest,\n  QueryAnswerType as BaseAnswers,\n  VectorQueryUnion as GeneratedVectorQuery,\n  VectorQuery as GeneratedRawVectorQuery,\n  QueryCaptionType as BaseCaptions,\n} from \"./generated/data/models\";\nimport { createSpan } from \"./tracing\";\nimport { deserialize, serialize } from \"./serialization\";\nimport {\n  AutocompleteOptions,\n  CountDocumentsOptions,\n  DeleteDocumentsOptions,\n  GetDocumentOptions,\n  IndexDocumentsOptions,\n  ListSearchResultsPageSettings,\n  MergeDocumentsOptions,\n  MergeOrUploadDocumentsOptions,\n  SearchDocumentsPageResult,\n  SearchDocumentsResult,\n  SearchIterator,\n  SearchOptions,\n  SelectFields,\n  SearchResult,\n  SuggestDocumentsResult,\n  SuggestOptions,\n  UploadDocumentsOptions,\n  NarrowedModel,\n  SelectArray,\n  SearchFieldArray,\n  VectorQuery,\n  QueryAnswer,\n  QueryCaption,\n  SemanticSearchOptions,\n  VectorizedQuery,\n} from \"./indexModels\";\nimport { createOdataMetadataPolicy } from \"./odataMetadataPolicy\";\nimport { IndexDocumentsBatch } from \"./indexDocumentsBatch\";\nimport { decode, encode } from \"./base64\";\nimport * as utils from \"./serviceUtils\";\nimport { IndexDocumentsClient } from \"./searchIndexingBufferedSender\";\nimport { ExtendedCommonClientOptions } from \"@azure/core-http-compat\";\nimport { KnownSearchAudience } from \"./searchAudience\";\n\n/**\n * Client options used to configure Cognitive Search API requests.\n */\nexport interface SearchClientOptions extends ExtendedCommonClientOptions {\n  /**\n   * The API version to use when communicating with the service.\n   * @deprecated use {@link serviceVersion} instead\n   */\n  apiVersion?: string;\n\n  /**\n   * The service version to use when communicating with the service.\n   */\n  serviceVersion?: string;\n\n  /**\n   * The Audience to use for authentication with Azure Active Directory (AAD). The\n   * audience is not considered when using a shared key.\n   * {@link KnownSearchAudience} can be used interchangeably with audience\n   */\n  audience?: string;\n}\n\n/**\n * Class used to perform operations against a search index,\n * including querying documents in the index as well as\n * adding, updating, and removing them.\n */\nexport class SearchClient<TModel extends object> implements IndexDocumentsClient<TModel> {\n  /// Maintenance note: when updating supported API versions,\n  /// the ContinuationToken logic will need to be updated below.\n\n  /**\n   *  The service version to use when communicating with the service.\n   */\n  public readonly serviceVersion: string = utils.defaultServiceVersion;\n\n  /**\n   * The API version to use when communicating with the service.\n   * @deprecated use {@Link serviceVersion} instead\n   */\n  public readonly apiVersion: string = utils.defaultServiceVersion;\n\n  /**\n   * The endpoint of the search service\n   */\n  public readonly endpoint: string;\n\n  /**\n   * The name of the index\n   */\n  public readonly indexName: string;\n\n  /**\n   * @internal\n   * @hidden\n   * A reference to the auto-generated SearchClient\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of SearchClient.\n   *\n   * Example usage:\n   * ```ts\n   * const { SearchClient, AzureKeyCredential } = require(\"@azure/search-documents\");\n   *\n   * const client = new SearchClient(\n   *   \"<endpoint>\",\n   *   \"<indexName>\",\n   *   new AzureKeyCredential(\"<Admin Key>\")\n   * );\n   * ```\n   *\n   * Optionally, the type of the model can be used to enable strong typing and type hints:\n   * ```ts\n   * type TModel = {\n   *   keyName: string;\n   *   field1?: string | null;\n   *   field2?: { anotherField?: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   ...\n   * );\n   * ```\n   *\n   * @param endpoint - The endpoint of the search service\n   * @param indexName - The name of the index\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Search client.\n   *\n   * @typeParam TModel - An optional type that represents the documents stored in\n   * the search index. For the best typing experience, all non-key fields should\n   * be marked optional and nullable, and the key property should have the\n   * non-nullable type `string`.\n   */\n  constructor(\n    endpoint: string,\n    indexName: string,\n    credential: KeyCredential | TokenCredential,\n    options: SearchClientOptions = {}\n  ) {\n    this.endpoint = endpoint;\n    this.indexName = indexName;\n\n    const internalClientPipelineOptions: InternalClientPipelineOptions = {\n      ...options,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          additionalAllowedHeaderNames: [\n            \"elapsed-time\",\n            \"Location\",\n            \"OData-MaxVersion\",\n            \"OData-Version\",\n            \"Prefer\",\n            \"throttle-reason\",\n          ],\n        },\n      },\n    };\n\n    this.serviceVersion =\n      options.serviceVersion ?? options.apiVersion ?? utils.defaultServiceVersion;\n    this.apiVersion = this.serviceVersion;\n\n    this.client = new GeneratedClient(\n      this.endpoint,\n      this.indexName,\n      this.serviceVersion,\n      internalClientPipelineOptions\n    );\n\n    if (isTokenCredential(credential)) {\n      const scope: string = options.audience\n        ? `${options.audience}/.default`\n        : `${KnownSearchAudience.AzurePublicCloud}/.default`;\n\n      this.client.pipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({ credential, scopes: scope })\n      );\n    } else {\n      this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));\n    }\n\n    this.client.pipeline.addPolicy(createOdataMetadataPolicy(\"none\"));\n  }\n\n  /**\n   * Retrieves the number of documents in the index.\n   * @param options - Options to the count operation.\n   */\n  public async getDocumentsCount(options: CountDocumentsOptions = {}): Promise<number> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-getDocumentsCount\", options);\n    try {\n      let documentsCount: number = 0;\n      await this.client.documents.count({\n        ...updatedOptions,\n        onResponse: (rawResponse, flatResponse) => {\n          documentsCount = Number(rawResponse.bodyAsText);\n          if (updatedOptions.onResponse) {\n            updatedOptions.onResponse(rawResponse, flatResponse);\n          }\n        },\n      });\n\n      return documentsCount;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Based on a partial searchText from the user, return a list\n   * of potential completion strings based on a specified suggester.\n   * @param searchText - The search text on which to base autocomplete results.\n   * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.\n   * @param options - Options to the autocomplete operation.\n   * @example\n   * ```ts\n   * import {\n   *   AzureKeyCredential,\n   *   SearchClient,\n   *   SearchFieldArray,\n   * } from \"@azure/search-documents\";\n   *\n   * type TModel = {\n   *   key: string;\n   *   azure?: { sdk: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   \"endpoint.azure\",\n   *   \"indexName\",\n   *   new AzureKeyCredential(\"key\")\n   * );\n   *\n   * const searchFields: SearchFieldArray<TModel> = [\"azure/sdk\"];\n   *\n   * const autocompleteResult = await client.autocomplete(\n   *   \"searchText\",\n   *   \"suggesterName\",\n   *   { searchFields }\n   * );\n   * ```\n   */\n  public async autocomplete(\n    searchText: string,\n    suggesterName: string,\n    options: AutocompleteOptions<TModel> = {}\n  ): Promise<AutocompleteResult> {\n    const { searchFields, ...nonFieldOptions } = options;\n    const fullOptions: AutocompleteRequest = {\n      searchText: searchText,\n      suggesterName: suggesterName,\n      searchFields: this.convertSearchFields(searchFields),\n      ...nonFieldOptions,\n    };\n\n    if (!fullOptions.searchText) {\n      throw new RangeError(\"searchText must be provided.\");\n    }\n\n    if (!fullOptions.suggesterName) {\n      throw new RangeError(\"suggesterName must be provided.\");\n    }\n\n    const { span, updatedOptions } = createSpan(\"SearchClient-autocomplete\", options);\n\n    try {\n      const result = await this.client.documents.autocompletePost(fullOptions, updatedOptions);\n      return result;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async searchDocuments<TFields extends SelectFields<TModel>>(\n    searchText?: string,\n    options: SearchOptions<TModel, TFields> = {},\n    nextPageParameters: GeneratedSearchRequest = {}\n  ): Promise<SearchDocumentsPageResult<TModel, TFields>> {\n    const {\n      searchFields,\n      select,\n      orderBy,\n      includeTotalCount,\n      vectorSearchOptions,\n      ...restOptions\n    } = options;\n\n    const semanticSearchOptions: SemanticSearchOptions | undefined = (restOptions as any)\n      .semanticSearchOptions;\n\n    delete (restOptions as any).semanticSearchOptions;\n\n    const { configurationName, errorMode, answers, captions, ...restSemanticOptions } =\n      semanticSearchOptions ?? {};\n    const { queries, filterMode, ...restVectorOptions } = vectorSearchOptions ?? {};\n\n    const fullOptions: GeneratedSearchRequest = {\n      ...restSemanticOptions,\n      ...restVectorOptions,\n      ...restOptions,\n      ...nextPageParameters,\n      searchFields: this.convertSearchFields(searchFields),\n      select: this.convertSelect<TFields>(select) || \"*\",\n      orderBy: this.convertOrderBy(orderBy),\n      includeTotalResultCount: includeTotalCount,\n      vectorQueries: queries?.map(this.convertVectorQuery.bind(this)),\n      answers: this.convertQueryAnswers(answers),\n      captions: this.convertCaptions(captions),\n      semanticErrorHandling: errorMode,\n      semanticConfigurationName: configurationName,\n      vectorFilterMode: filterMode,\n    };\n\n    const { span, updatedOptions } = createSpan(\"SearchClient-searchDocuments\", options);\n\n    try {\n      const result = await this.client.documents.searchPost(\n        {\n          ...fullOptions,\n          searchText: searchText,\n        },\n        updatedOptions\n      );\n\n      const {\n        results,\n        nextLink,\n        nextPageParameters: resultNextPageParameters,\n        semanticPartialResponseReason: semanticErrorReason,\n        semanticPartialResponseType: semanticSearchResultsType,\n        ...restResult\n      } = result;\n\n      const modifiedResults = utils.generatedSearchResultToPublicSearchResult<TModel, TFields>(\n        results\n      );\n\n      const converted: SearchDocumentsPageResult<TModel, TFields> = {\n        ...restResult,\n        results: modifiedResults,\n        semanticErrorReason: semanticErrorReason as `${KnownSemanticErrorReason}`,\n        semanticSearchResultsType: semanticSearchResultsType as `${KnownSemanticSearchResultsType}`,\n        continuationToken: this.encodeContinuationToken(nextLink, resultNextPageParameters),\n      };\n\n      return deserialize<SearchDocumentsPageResult<TModel, TFields>>(converted);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listSearchResultsPage<TFields extends SelectFields<TModel>>(\n    searchText?: string,\n    options: SearchOptions<TModel, TFields> = {},\n    settings: ListSearchResultsPageSettings = {}\n  ): AsyncIterableIterator<SearchDocumentsPageResult<TModel, TFields>> {\n    let decodedContinuation = this.decodeContinuationToken(settings.continuationToken);\n    let result = await this.searchDocuments(\n      searchText,\n      options,\n      decodedContinuation?.nextPageParameters\n    );\n\n    yield result;\n\n    // Technically, we should also leverage nextLink, but the generated code\n    // doesn't support this yet.\n    while (result.continuationToken) {\n      decodedContinuation = this.decodeContinuationToken(result.continuationToken);\n      result = await this.searchDocuments(\n        searchText,\n        options,\n        decodedContinuation?.nextPageParameters\n      );\n      yield result;\n    }\n  }\n\n  private async *listSearchResultsAll<TFields extends SelectFields<TModel>>(\n    firstPage: SearchDocumentsPageResult<TModel, TFields>,\n    searchText?: string,\n    options: SearchOptions<TModel, TFields> = {}\n  ): AsyncIterableIterator<SearchResult<TModel, TFields>> {\n    yield* firstPage.results;\n    if (firstPage.continuationToken) {\n      for await (const page of this.listSearchResultsPage(searchText, options, {\n        continuationToken: firstPage.continuationToken,\n      })) {\n        yield* page.results;\n      }\n    }\n  }\n\n  private listSearchResults<TFields extends SelectFields<TModel>>(\n    firstPage: SearchDocumentsPageResult<TModel, TFields>,\n    searchText?: string,\n    options: SearchOptions<TModel, TFields> = {}\n  ): SearchIterator<TModel, TFields> {\n    const iter = this.listSearchResultsAll(firstPage, searchText, options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: ListSearchResultsPageSettings = {}) => {\n        return this.listSearchResultsPage(searchText, options, settings);\n      },\n    };\n  }\n\n  /**\n   * Performs a search on the current index given\n   * the specified arguments.\n   * @param searchText - Text to search\n   * @param options - Options for the search operation.\n   * @example\n   * ```ts\n   * import {\n   *   AzureKeyCredential,\n   *   SearchClient,\n   *   SearchFieldArray,\n   * } from \"@azure/search-documents\";\n   *\n   * type TModel = {\n   *   key: string;\n   *   azure?: { sdk: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   \"endpoint.azure\",\n   *   \"indexName\",\n   *   new AzureKeyCredential(\"key\")\n   * );\n   *\n   * const select = [\"azure/sdk\"] as const;\n   * const searchFields: SearchFieldArray<TModel> = [\"azure/sdk\"];\n   *\n   * const searchResult = await client.search(\"searchText\", {\n   *   select,\n   *   searchFields,\n   * });\n   * ```\n   */\n  public async search<TFields extends SelectFields<TModel>>(\n    searchText?: string,\n    options?: SearchOptions<TModel, TFields>\n  ): Promise<SearchDocumentsResult<TModel, TFields>> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-search\", options);\n\n    try {\n      const pageResult = await this.searchDocuments<TFields>(searchText, updatedOptions);\n\n      return {\n        ...pageResult,\n        results: this.listSearchResults(pageResult, searchText, updatedOptions),\n      };\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns a short list of suggestions based on the searchText\n   * and specified suggester.\n   * @param searchText - The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.\n   * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.\n   * @param options - Options for the suggest operation\n   * @example\n   * ```ts\n   * import {\n   *   AzureKeyCredential,\n   *   SearchClient,\n   *   SearchFieldArray,\n   * } from \"@azure/search-documents\";\n   *\n   * type TModel = {\n   *   key: string;\n   *   azure?: { sdk: string | null } | null;\n   * };\n   *\n   * const client = new SearchClient<TModel>(\n   *   \"endpoint.azure\",\n   *   \"indexName\",\n   *   new AzureKeyCredential(\"key\")\n   * );\n   *\n   * const select = [\"azure/sdk\"] as const;\n   * const searchFields: SearchFieldArray<TModel> = [\"azure/sdk\"];\n   *\n   * const suggestResult = await client.suggest(\"searchText\", \"suggesterName\", {\n   *   select,\n   *   searchFields,\n   * });\n   * ```\n   */\n  public async suggest<TFields extends SelectFields<TModel> = never>(\n    searchText: string,\n    suggesterName: string,\n    options: SuggestOptions<TModel, TFields> = {}\n  ): Promise<SuggestDocumentsResult<TModel, TFields>> {\n    const { select, searchFields, orderBy, ...nonFieldOptions } = options;\n    const fullOptions: SuggestRequest = {\n      searchText: searchText,\n      suggesterName: suggesterName,\n      searchFields: this.convertSearchFields(searchFields),\n      select: this.convertSelect<TFields>(select),\n      orderBy: this.convertOrderBy(orderBy),\n      ...nonFieldOptions,\n    };\n\n    if (!fullOptions.searchText) {\n      throw new RangeError(\"searchText must be provided.\");\n    }\n\n    if (!fullOptions.suggesterName) {\n      throw new RangeError(\"suggesterName must be provided.\");\n    }\n\n    const { span, updatedOptions } = createSpan(\"SearchClient-suggest\", options);\n\n    try {\n      const result = await this.client.documents.suggestPost(fullOptions, updatedOptions);\n\n      const modifiedResult = utils.generatedSuggestDocumentsResultToPublicSuggestDocumentsResult<\n        TModel,\n        TFields\n      >(result);\n\n      return deserialize<SuggestDocumentsResult<TModel, TFields>>(modifiedResult);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieve a particular document from the index by key.\n   * @param key - The primary key value of the document\n   * @param options - Additional options\n   */\n  public async getDocument<TFields extends SelectFields<TModel>>(\n    key: string,\n    options: GetDocumentOptions<TModel, TFields> = {}\n  ): Promise<NarrowedModel<TModel, TFields>> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-getDocument\", options);\n    try {\n      const result = await this.client.documents.get(key, {\n        ...updatedOptions,\n        selectedFields: updatedOptions.selectedFields as string[] | undefined, // todo: make sure undefined is in beta\n      });\n      return deserialize<NarrowedModel<TModel, TFields>>(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)\n   * for the given set of documents.\n   * This operation may partially succeed and not all document operations will\n   * be reflected in the index. If you would like to treat this as an exception,\n   * set the `throwOnAnyFailure` option to true.\n   * For more details about how merging works, see: https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents\n   * @param batch - An array of actions to perform on the index.\n   * @param options - Additional options.\n   */\n  public async indexDocuments(\n    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n    batch: IndexDocumentsBatch<TModel>,\n    options: IndexDocumentsOptions = {}\n  ): Promise<IndexDocumentsResult> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-indexDocuments\", options);\n    try {\n      let status: number = 0;\n      const result = await this.client.documents.index(\n        { actions: serialize(batch.actions) },\n        {\n          ...updatedOptions,\n          onResponse: (rawResponse, flatResponse) => {\n            status = rawResponse.status;\n            if (updatedOptions.onResponse) {\n              updatedOptions.onResponse(rawResponse, flatResponse);\n            }\n          },\n        }\n      );\n      if (options.throwOnAnyFailure && status === 207) {\n        throw result;\n      }\n      return result;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Upload an array of documents to the index.\n   * @param documents - The documents to upload.\n   * @param options - Additional options.\n   */\n  public async uploadDocuments(\n    documents: TModel[],\n    options: UploadDocumentsOptions = {}\n  ): Promise<IndexDocumentsResult> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-uploadDocuments\", options);\n\n    const batch = new IndexDocumentsBatch<TModel>();\n    batch.upload(documents);\n\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Update a set of documents in the index.\n   * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents\n   * @param documents - The updated documents.\n   * @param options - Additional options.\n   */\n  public async mergeDocuments(\n    documents: TModel[],\n    options: MergeDocumentsOptions = {}\n  ): Promise<IndexDocumentsResult> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-mergeDocuments\", options);\n\n    const batch = new IndexDocumentsBatch<TModel>();\n    batch.merge(documents);\n\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Update a set of documents in the index or upload them if they don't exist.\n   * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents\n   * @param documents - The updated documents.\n   * @param options - Additional options.\n   */\n  public async mergeOrUploadDocuments(\n    documents: TModel[],\n    options: MergeOrUploadDocumentsOptions = {}\n  ): Promise<IndexDocumentsResult> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-mergeDocuments\", options);\n\n    const batch = new IndexDocumentsBatch<TModel>();\n    batch.mergeOrUpload(documents);\n\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Delete a set of documents.\n   * @param documents - Documents to be deleted.\n   * @param options - Additional options.\n   */\n  public async deleteDocuments(\n    documents: TModel[],\n    options?: DeleteDocumentsOptions\n  ): Promise<IndexDocumentsResult>;\n\n  /**\n   * Delete a set of documents.\n   * @param keyName - The name of their primary key in the index.\n   * @param keyValues - The primary key values of documents to delete.\n   * @param options - Additional options.\n   */\n  public async deleteDocuments(\n    keyName: keyof TModel,\n    keyValues: string[],\n    options?: DeleteDocumentsOptions\n  ): Promise<IndexDocumentsResult>;\n\n  public async deleteDocuments(\n    keyNameOrDocuments: keyof TModel | TModel[],\n    keyValuesOrOptions?: string[] | DeleteDocumentsOptions,\n    options: DeleteDocumentsOptions = {}\n  ): Promise<IndexDocumentsResult> {\n    const { span, updatedOptions } = createSpan(\"SearchClient-deleteDocuments\", options);\n\n    const batch = new IndexDocumentsBatch<TModel>();\n    if (typeof keyNameOrDocuments === \"string\") {\n      batch.delete(keyNameOrDocuments, keyValuesOrOptions as string[]);\n    } else {\n      batch.delete(keyNameOrDocuments as TModel[]);\n    }\n\n    try {\n      return await this.indexDocuments(batch, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private encodeContinuationToken(\n    nextLink: string | undefined,\n    nextPageParameters: GeneratedSearchRequest | undefined\n  ): string | undefined {\n    if (!nextLink || !nextPageParameters) {\n      return undefined;\n    }\n    const payload = JSON.stringify({\n      apiVersion: this.apiVersion,\n      nextLink,\n      nextPageParameters,\n    });\n    return encode(payload);\n  }\n\n  private decodeContinuationToken(\n    token?: string\n  ): { nextPageParameters: GeneratedSearchRequest; nextLink: string } | undefined {\n    if (!token) {\n      return undefined;\n    }\n\n    const decodedToken = decode(token);\n\n    try {\n      const result: {\n        apiVersion: string;\n        nextLink: string;\n        nextPageParameters: GeneratedSearchRequest;\n      } = JSON.parse(decodedToken);\n\n      if (result.apiVersion !== this.apiVersion) {\n        throw new RangeError(`Continuation token uses unsupported apiVersion \"${this.apiVersion}\"`);\n      }\n\n      return {\n        nextLink: result.nextLink,\n        nextPageParameters: result.nextPageParameters,\n      };\n    } catch (e: any) {\n      throw new Error(`Corrupted or invalid continuation token: ${decodedToken}`);\n    }\n  }\n\n  private convertSelect<TFields extends SelectFields<TModel>>(\n    select?: SelectArray<TFields>\n  ): string | undefined {\n    if (select) {\n      return select.join(\",\");\n    }\n    return select;\n  }\n\n  private convertVectorQueryFields(fields?: SearchFieldArray<TModel>): string | undefined {\n    if (fields) {\n      return fields.join(\",\");\n    }\n    return fields;\n  }\n\n  private convertSearchFields(searchFields?: SearchFieldArray<TModel>): string | undefined {\n    if (searchFields) {\n      return searchFields.join(\",\");\n    }\n    return searchFields;\n  }\n\n  private convertOrderBy(orderBy?: string[]): string | undefined {\n    if (orderBy) {\n      return orderBy.join(\",\");\n    }\n    return orderBy;\n  }\n\n  private convertQueryAnswers(answers?: QueryAnswer): BaseAnswers | undefined {\n    if (!answers) {\n      return answers;\n    }\n\n    const config = [];\n    const { answerType: output, count, threshold } = answers;\n\n    if (count) {\n      config.push(`count-${count}`);\n    }\n\n    if (threshold) {\n      config.push(`threshold-${threshold}`);\n    }\n\n    if (config.length) {\n      return output + `|${config.join(\",\")}`;\n    }\n\n    return output;\n  }\n\n  private convertCaptions(captions?: QueryCaption): BaseCaptions | undefined {\n    if (!captions) {\n      return captions;\n    }\n\n    const config = [];\n    const { captionType: output, highlight } = captions;\n\n    if (highlight !== undefined) {\n      config.push(`highlight-${highlight}`);\n    }\n\n    if (config.length) {\n      return output + `|${config.join(\",\")}`;\n    }\n\n    return output;\n  }\n\n  private convertVectorQuery(): undefined;\n  private convertVectorQuery(vectorQuery: VectorizedQuery<TModel>): GeneratedRawVectorQuery;\n  private convertVectorQuery(vectorQuery: VectorQuery<TModel>): GeneratedVectorQuery;\n  private convertVectorQuery(vectorQuery?: VectorQuery<TModel>): GeneratedVectorQuery | undefined {\n    if (!vectorQuery) {\n      return vectorQuery;\n    }\n    return { ...vectorQuery, fields: this.convertVectorQueryFields(vectorQuery?.fields) };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}