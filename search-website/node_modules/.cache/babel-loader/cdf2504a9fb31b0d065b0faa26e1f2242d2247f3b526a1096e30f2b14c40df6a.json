{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { SearchServiceClient as GeneratedClient } from \"./generated/service/searchServiceClient\";\nimport { logger } from \"./logger\";\nimport { createSearchApiKeyCredentialPolicy } from \"./searchApiKeyCredentialPolicy\";\nimport * as utils from \"./serviceUtils\";\nimport { createSpan } from \"./tracing\";\nimport { createOdataMetadataPolicy } from \"./odataMetadataPolicy\";\nimport { KnownSearchAudience } from \"./searchAudience\";\n/**\n * Class to perform operations to manage\n * (create, update, list/delete)\n * indexers, datasources & skillsets.\n */\nexport class SearchIndexerClient {\n  /**\n   * Creates an instance of SearchIndexerClient.\n   *\n   * Example usage:\n   * ```ts\n   * const { SearchIndexerClient, AzureKeyCredential } = require(\"@azure/search-documents\");\n   *\n   * const client = new SearchIndexerClient(\n   *   \"<endpoint>\",\n   *   new AzureKeyCredential(\"<Admin Key>\");\n   * );\n   * ```\n   * @param endpoint - The endpoint of the search service\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Search client.\n   */\n  constructor(endpoint, credential, options = {}) {\n    var _a, _b;\n    /**\n     * The API version to use when communicating with the service.\n     */\n    this.serviceVersion = utils.defaultServiceVersion;\n    /**\n     * The API version to use when communicating with the service.\n     * @deprecated use {@Link serviceVersion} instead\n     */\n    this.apiVersion = utils.defaultServiceVersion;\n    this.endpoint = endpoint;\n    const internalClientPipelineOptions = Object.assign(Object.assign({}, options), {\n      loggingOptions: {\n        logger: logger.info,\n        additionalAllowedHeaderNames: [\"elapsed-time\", \"Location\", \"OData-MaxVersion\", \"OData-Version\", \"Prefer\", \"throttle-reason\"]\n      }\n    });\n    this.serviceVersion = (_b = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : options.apiVersion) !== null && _b !== void 0 ? _b : utils.defaultServiceVersion;\n    this.apiVersion = this.serviceVersion;\n    this.client = new GeneratedClient(this.endpoint, this.serviceVersion, internalClientPipelineOptions);\n    if (isTokenCredential(credential)) {\n      const scope = options.audience ? `${options.audience}/.default` : `${KnownSearchAudience.AzurePublicCloud}/.default`;\n      this.client.pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential,\n        scopes: scope\n      }));\n    } else {\n      this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));\n    }\n    this.client.pipeline.addPolicy(createOdataMetadataPolicy(\"minimal\"));\n  }\n  /**\n   * Retrieves a list of existing indexers in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  async listIndexers(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-listIndexers\", options);\n    try {\n      const result = await this.client.indexers.list(updatedOptions);\n      return result.indexers.map(utils.generatedSearchIndexerToPublicSearchIndexer);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves a list of names of existing indexers in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  async listIndexersNames(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-listIndexersNames\", options);\n    try {\n      const result = await this.client.indexers.list(Object.assign(Object.assign({}, updatedOptions), {\n        select: \"name\"\n      }));\n      return result.indexers.map(idx => idx.name);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves a list of existing data sources in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  async listDataSourceConnections(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-listDataSourceConnections\", options);\n    try {\n      const result = await this.client.dataSources.list(updatedOptions);\n      return result.dataSources.map(utils.generatedDataSourceToPublicDataSource);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves a list of names of existing data sources in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  async listDataSourceConnectionsNames(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-listDataSourceConnectionsNames\", options);\n    try {\n      const result = await this.client.dataSources.list(Object.assign(Object.assign({}, updatedOptions), {\n        select: \"name\"\n      }));\n      return result.dataSources.map(ds => ds.name);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves a list of existing Skillsets in the service.\n   * @param options - Options to the list Skillsets operation.\n   */\n  async listSkillsets(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-listSkillsets\", options);\n    try {\n      const result = await this.client.skillsets.list(updatedOptions);\n      return result.skillsets.map(utils.generatedSkillsetToPublicSkillset);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves a list of names of existing Skillsets in the service.\n   * @param options - Options to the list Skillsets operation.\n   */\n  async listSkillsetsNames(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-listSkillsetsNames\", options);\n    try {\n      const result = await this.client.skillsets.list(Object.assign(Object.assign({}, updatedOptions), {\n        select: \"name\"\n      }));\n      return result.skillsets.map(sks => sks.name);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves information about an Indexer.\n   * @param indexerName - The name of the Indexer.\n   * @param options - Additional optional arguments.\n   */\n  async getIndexer(indexerName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-getIndexer\", options);\n    try {\n      const result = await this.client.indexers.get(indexerName, updatedOptions);\n      return utils.generatedSearchIndexerToPublicSearchIndexer(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves information about a DataSource\n   * @param dataSourceName - The name of the DataSource\n   * @param options - Additional optional arguments\n   */\n  async getDataSourceConnection(dataSourceConnectionName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-getDataSourceConnection\", options);\n    try {\n      const result = await this.client.dataSources.get(dataSourceConnectionName, updatedOptions);\n      return utils.generatedDataSourceToPublicDataSource(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves information about an Skillset.\n   * @param indexName - The name of the Skillset.\n   * @param options - Additional optional arguments.\n   */\n  async getSkillset(skillsetName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-getSkillset\", options);\n    try {\n      const result = await this.client.skillsets.get(skillsetName, updatedOptions);\n      return utils.generatedSkillsetToPublicSkillset(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new indexer in a search service.\n   * @param indexer - The indexer definition to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  async createIndexer(indexer, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-createIndexer\", options);\n    try {\n      const result = await this.client.indexers.create(utils.publicSearchIndexerToGeneratedSearchIndexer(indexer), updatedOptions);\n      return utils.generatedSearchIndexerToPublicSearchIndexer(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new dataSource in a search service.\n   * @param dataSourceConnection - The dataSource definition to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  async createDataSourceConnection(dataSourceConnection, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-createDataSourceConnection\", options);\n    try {\n      const result = await this.client.dataSources.create(utils.publicDataSourceToGeneratedDataSource(dataSourceConnection), updatedOptions);\n      return utils.generatedDataSourceToPublicDataSource(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new skillset in a search service.\n   * @param skillset - The skillset containing one or more skills to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  async createSkillset(skillset, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-createSkillset\", options);\n    try {\n      const result = await this.client.skillsets.create(utils.publicSkillsetToGeneratedSkillset(skillset), updatedOptions);\n      return utils.generatedSkillsetToPublicSkillset(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new indexer or modifies an existing one.\n   * @param indexer - The information describing the indexer to be created/updated.\n   * @param options - Additional optional arguments.\n   */\n  async createOrUpdateIndexer(indexer, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-createOrUpdateIndexer\", options);\n    try {\n      const etag = options.onlyIfUnchanged ? indexer.etag : undefined;\n      const result = await this.client.indexers.createOrUpdate(indexer.name, utils.publicSearchIndexerToGeneratedSearchIndexer(indexer), Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n      return utils.generatedSearchIndexerToPublicSearchIndexer(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new datasource or modifies an existing one.\n   * @param dataSourceConnection - The information describing the datasource to be created/updated.\n   * @param options - Additional optional arguments.\n   */\n  async createOrUpdateDataSourceConnection(dataSourceConnection, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-createOrUpdateDataSourceConnection\", options);\n    try {\n      const etag = options.onlyIfUnchanged ? dataSourceConnection.etag : undefined;\n      const result = await this.client.dataSources.createOrUpdate(dataSourceConnection.name, utils.publicDataSourceToGeneratedDataSource(dataSourceConnection), Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n      return utils.generatedDataSourceToPublicDataSource(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new Skillset or modifies an existing one.\n   * @param skillset - The information describing the index to be created.\n   * @param options - Additional optional arguments.\n   */\n  async createOrUpdateSkillset(skillset, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-createOrUpdateSkillset\", options);\n    try {\n      const etag = options.onlyIfUnchanged ? skillset.etag : undefined;\n      const result = await this.client.skillsets.createOrUpdate(skillset.name, utils.publicSkillsetToGeneratedSkillset(skillset), Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n      return utils.generatedSkillsetToPublicSkillset(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes an existing indexer.\n   * @param indexer - Indexer/Name of the indexer to delete.\n   * @param options - Additional optional arguments.\n   */\n  async deleteIndexer(indexer, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-deleteIndexer\", options);\n    try {\n      const indexerName = typeof indexer === \"string\" ? indexer : indexer.name;\n      const etag = typeof indexer === \"string\" ? undefined : options.onlyIfUnchanged ? indexer.etag : undefined;\n      await this.client.indexers.delete(indexerName, Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes an existing datasource.\n   * @param dataSource - Datasource/Name of the datasource to delete.\n   * @param options - Additional optional arguments.\n   */\n  async deleteDataSourceConnection(dataSourceConnection, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-deleteDataSourceConnection\", options);\n    try {\n      const dataSourceConnectionName = typeof dataSourceConnection === \"string\" ? dataSourceConnection : dataSourceConnection.name;\n      const etag = typeof dataSourceConnection === \"string\" ? undefined : options.onlyIfUnchanged ? dataSourceConnection.etag : undefined;\n      await this.client.dataSources.delete(dataSourceConnectionName, Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes an existing Skillset.\n   * @param skillset - Skillset/Name of the Skillset to delete.\n   * @param options - Additional optional arguments.\n   */\n  async deleteSkillset(skillset, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-deleteSkillset\", options);\n    try {\n      const skillsetName = typeof skillset === \"string\" ? skillset : skillset.name;\n      const etag = typeof skillset === \"string\" ? undefined : options.onlyIfUnchanged ? skillset.etag : undefined;\n      await this.client.skillsets.delete(skillsetName, Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Returns the current status and execution history of an indexer.\n   * @param indexerName - The name of the indexer.\n   * @param options - Additional optional arguments.\n   */\n  async getIndexerStatus(indexerName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-getIndexerStatus\", options);\n    try {\n      const result = await this.client.indexers.getStatus(indexerName, updatedOptions);\n      return result;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Resets the change tracking state associated with an indexer.\n   * @param indexerName - The name of the indexer to reset.\n   * @param options - Additional optional arguments.\n   */\n  async resetIndexer(indexerName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-resetIndexer\", options);\n    try {\n      await this.client.indexers.reset(indexerName, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Runs an indexer on-demand.\n   * @param indexerName - The name of the indexer to run.\n   * @param options - Additional optional arguments.\n   */\n  async runIndexer(indexerName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexerClient-runIndexer\", options);\n    try {\n      await this.client.indexers.run(indexerName, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}","map":{"version":3,"names":["isTokenCredential","bearerTokenAuthenticationPolicy","SearchServiceClient","GeneratedClient","logger","createSearchApiKeyCredentialPolicy","utils","createSpan","createOdataMetadataPolicy","KnownSearchAudience","SearchIndexerClient","constructor","endpoint","credential","options","serviceVersion","defaultServiceVersion","apiVersion","internalClientPipelineOptions","Object","assign","loggingOptions","info","additionalAllowedHeaderNames","_b","_a","client","scope","audience","AzurePublicCloud","pipeline","addPolicy","scopes","listIndexers","span","updatedOptions","result","indexers","list","map","generatedSearchIndexerToPublicSearchIndexer","e","setStatus","status","error","message","end","listIndexersNames","select","idx","name","listDataSourceConnections","dataSources","generatedDataSourceToPublicDataSource","listDataSourceConnectionsNames","ds","listSkillsets","skillsets","generatedSkillsetToPublicSkillset","listSkillsetsNames","sks","getIndexer","indexerName","get","getDataSourceConnection","dataSourceConnectionName","getSkillset","skillsetName","createIndexer","indexer","create","publicSearchIndexerToGeneratedSearchIndexer","createDataSourceConnection","dataSourceConnection","publicDataSourceToGeneratedDataSource","createSkillset","skillset","publicSkillsetToGeneratedSkillset","createOrUpdateIndexer","etag","onlyIfUnchanged","undefined","createOrUpdate","ifMatch","createOrUpdateDataSourceConnection","createOrUpdateSkillset","deleteIndexer","delete","deleteDataSourceConnection","deleteSkillset","getIndexerStatus","getStatus","resetIndexer","reset","runIndexer","run"],"sources":["C:\\Users\\julia\\Desktop\\cwb-slt\\search-website\\node_modules\\@azure\\search-documents\\src\\searchIndexerClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { InternalClientPipelineOptions } from \"@azure/core-client\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { SearchIndexerStatus } from \"./generated/service/models\";\nimport { SearchServiceClient as GeneratedClient } from \"./generated/service/searchServiceClient\";\nimport { logger } from \"./logger\";\nimport { createSearchApiKeyCredentialPolicy } from \"./searchApiKeyCredentialPolicy\";\nimport {\n  CreateDataSourceConnectionOptions,\n  CreateIndexerOptions,\n  CreateOrUpdateSkillsetOptions,\n  CreateSkillsetOptions,\n  CreateorUpdateDataSourceConnectionOptions,\n  CreateorUpdateIndexerOptions,\n  DeleteDataSourceConnectionOptions,\n  DeleteIndexerOptions,\n  DeleteSkillsetOptions,\n  GetDataSourceConnectionOptions,\n  GetIndexerOptions,\n  GetIndexerStatusOptions,\n  GetSkillSetOptions,\n  ListDataSourceConnectionsOptions,\n  ListIndexersOptions,\n  ListSkillsetsOptions,\n  ResetIndexerOptions,\n  RunIndexerOptions,\n  SearchIndexer,\n  SearchIndexerDataSourceConnection,\n  SearchIndexerSkillset,\n} from \"./serviceModels\";\nimport * as utils from \"./serviceUtils\";\nimport { createSpan } from \"./tracing\";\nimport { createOdataMetadataPolicy } from \"./odataMetadataPolicy\";\nimport { ExtendedCommonClientOptions } from \"@azure/core-http-compat\";\nimport { KnownSearchAudience } from \"./searchAudience\";\n\n/**\n * Client options used to configure Cognitive Search API requests.\n */\nexport interface SearchIndexerClientOptions extends ExtendedCommonClientOptions {\n  /**\n   * The API version to use when communicating with the service.\n   * @deprecated use {@Link serviceVersion} instead\n   */\n  apiVersion?: string;\n\n  /**\n   * The service version to use when communicating with the service.\n   */\n  serviceVersion?: string;\n\n  /**\n   * The Audience to use for authentication with Azure Active Directory (AAD). The\n   * audience is not considered when using a shared key.\n   * {@link KnownSearchAudience} can be used interchangeably with audience\n   */\n  audience?: string;\n}\n\n/**\n * Class to perform operations to manage\n * (create, update, list/delete)\n * indexers, datasources & skillsets.\n */\nexport class SearchIndexerClient {\n  /**\n   * The API version to use when communicating with the service.\n   */\n  public readonly serviceVersion: string = utils.defaultServiceVersion;\n\n  /**\n   * The API version to use when communicating with the service.\n   * @deprecated use {@Link serviceVersion} instead\n   */\n  public readonly apiVersion: string = utils.defaultServiceVersion;\n\n  /**\n   * The endpoint of the search service\n   */\n  public readonly endpoint: string;\n\n  /**\n   * @internal\n   * @hidden\n   * A reference to the auto-generated SearchServiceClient\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of SearchIndexerClient.\n   *\n   * Example usage:\n   * ```ts\n   * const { SearchIndexerClient, AzureKeyCredential } = require(\"@azure/search-documents\");\n   *\n   * const client = new SearchIndexerClient(\n   *   \"<endpoint>\",\n   *   new AzureKeyCredential(\"<Admin Key>\");\n   * );\n   * ```\n   * @param endpoint - The endpoint of the search service\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Search client.\n   */\n  constructor(\n    endpoint: string,\n    credential: KeyCredential | TokenCredential,\n    options: SearchIndexerClientOptions = {}\n  ) {\n    this.endpoint = endpoint;\n\n    const internalClientPipelineOptions: InternalClientPipelineOptions = {\n      ...options,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          additionalAllowedHeaderNames: [\n            \"elapsed-time\",\n            \"Location\",\n            \"OData-MaxVersion\",\n            \"OData-Version\",\n            \"Prefer\",\n            \"throttle-reason\",\n          ],\n        },\n      },\n    };\n\n    this.serviceVersion =\n      options.serviceVersion ?? options.apiVersion ?? utils.defaultServiceVersion;\n    this.apiVersion = this.serviceVersion;\n\n    this.client = new GeneratedClient(\n      this.endpoint,\n      this.serviceVersion,\n      internalClientPipelineOptions\n    );\n\n    if (isTokenCredential(credential)) {\n      const scope: string = options.audience\n        ? `${options.audience}/.default`\n        : `${KnownSearchAudience.AzurePublicCloud}/.default`;\n\n      this.client.pipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({ credential, scopes: scope })\n      );\n    } else {\n      this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));\n    }\n\n    this.client.pipeline.addPolicy(createOdataMetadataPolicy(\"minimal\"));\n  }\n\n  /**\n   * Retrieves a list of existing indexers in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  public async listIndexers(options: ListIndexersOptions = {}): Promise<Array<SearchIndexer>> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-listIndexers\", options);\n    try {\n      const result = await this.client.indexers.list(updatedOptions);\n      return result.indexers.map(utils.generatedSearchIndexerToPublicSearchIndexer);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves a list of names of existing indexers in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  public async listIndexersNames(options: ListIndexersOptions = {}): Promise<Array<string>> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-listIndexersNames\", options);\n    try {\n      const result = await this.client.indexers.list({\n        ...updatedOptions,\n        select: \"name\",\n      });\n      return result.indexers.map((idx) => idx.name);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves a list of existing data sources in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  public async listDataSourceConnections(\n    options: ListDataSourceConnectionsOptions = {}\n  ): Promise<Array<SearchIndexerDataSourceConnection>> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-listDataSourceConnections\",\n      options\n    );\n    try {\n      const result = await this.client.dataSources.list(updatedOptions);\n      return result.dataSources.map(utils.generatedDataSourceToPublicDataSource);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves a list of names of existing data sources in the service.\n   * @param options - Options to the list indexers operation.\n   */\n  public async listDataSourceConnectionsNames(\n    options: ListDataSourceConnectionsOptions = {}\n  ): Promise<Array<string>> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-listDataSourceConnectionsNames\",\n      options\n    );\n    try {\n      const result = await this.client.dataSources.list({\n        ...updatedOptions,\n        select: \"name\",\n      });\n      return result.dataSources.map((ds) => ds.name);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves a list of existing Skillsets in the service.\n   * @param options - Options to the list Skillsets operation.\n   */\n  public async listSkillsets(\n    options: ListSkillsetsOptions = {}\n  ): Promise<Array<SearchIndexerSkillset>> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-listSkillsets\", options);\n    try {\n      const result = await this.client.skillsets.list(updatedOptions);\n      return result.skillsets.map(utils.generatedSkillsetToPublicSkillset);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves a list of names of existing Skillsets in the service.\n   * @param options - Options to the list Skillsets operation.\n   */\n  public async listSkillsetsNames(options: ListSkillsetsOptions = {}): Promise<Array<string>> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-listSkillsetsNames\", options);\n    try {\n      const result = await this.client.skillsets.list({\n        ...updatedOptions,\n        select: \"name\",\n      });\n      return result.skillsets.map((sks) => sks.name);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves information about an Indexer.\n   * @param indexerName - The name of the Indexer.\n   * @param options - Additional optional arguments.\n   */\n  public async getIndexer(\n    indexerName: string,\n    options: GetIndexerOptions = {}\n  ): Promise<SearchIndexer> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-getIndexer\", options);\n    try {\n      const result = await this.client.indexers.get(indexerName, updatedOptions);\n      return utils.generatedSearchIndexerToPublicSearchIndexer(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves information about a DataSource\n   * @param dataSourceName - The name of the DataSource\n   * @param options - Additional optional arguments\n   */\n  public async getDataSourceConnection(\n    dataSourceConnectionName: string,\n    options: GetDataSourceConnectionOptions = {}\n  ): Promise<SearchIndexerDataSourceConnection> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-getDataSourceConnection\",\n      options\n    );\n    try {\n      const result = await this.client.dataSources.get(dataSourceConnectionName, updatedOptions);\n      return utils.generatedDataSourceToPublicDataSource(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves information about an Skillset.\n   * @param indexName - The name of the Skillset.\n   * @param options - Additional optional arguments.\n   */\n  public async getSkillset(\n    skillsetName: string,\n    options: GetSkillSetOptions = {}\n  ): Promise<SearchIndexerSkillset> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-getSkillset\", options);\n    try {\n      const result = await this.client.skillsets.get(skillsetName, updatedOptions);\n      return utils.generatedSkillsetToPublicSkillset(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new indexer in a search service.\n   * @param indexer - The indexer definition to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  public async createIndexer(\n    indexer: SearchIndexer,\n    options: CreateIndexerOptions = {}\n  ): Promise<SearchIndexer> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-createIndexer\", options);\n    try {\n      const result = await this.client.indexers.create(\n        utils.publicSearchIndexerToGeneratedSearchIndexer(indexer),\n        updatedOptions\n      );\n      return utils.generatedSearchIndexerToPublicSearchIndexer(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new dataSource in a search service.\n   * @param dataSourceConnection - The dataSource definition to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  public async createDataSourceConnection(\n    dataSourceConnection: SearchIndexerDataSourceConnection,\n    options: CreateDataSourceConnectionOptions = {}\n  ): Promise<SearchIndexerDataSourceConnection> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-createDataSourceConnection\",\n      options\n    );\n    try {\n      const result = await this.client.dataSources.create(\n        utils.publicDataSourceToGeneratedDataSource(dataSourceConnection),\n        updatedOptions\n      );\n      return utils.generatedDataSourceToPublicDataSource(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new skillset in a search service.\n   * @param skillset - The skillset containing one or more skills to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  public async createSkillset(\n    skillset: SearchIndexerSkillset,\n    options: CreateSkillsetOptions = {}\n  ): Promise<SearchIndexerSkillset> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-createSkillset\", options);\n    try {\n      const result = await this.client.skillsets.create(\n        utils.publicSkillsetToGeneratedSkillset(skillset),\n        updatedOptions\n      );\n      return utils.generatedSkillsetToPublicSkillset(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new indexer or modifies an existing one.\n   * @param indexer - The information describing the indexer to be created/updated.\n   * @param options - Additional optional arguments.\n   */\n  public async createOrUpdateIndexer(\n    indexer: SearchIndexer,\n    options: CreateorUpdateIndexerOptions = {}\n  ): Promise<SearchIndexer> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-createOrUpdateIndexer\",\n      options\n    );\n    try {\n      const etag = options.onlyIfUnchanged ? indexer.etag : undefined;\n\n      const result = await this.client.indexers.createOrUpdate(\n        indexer.name,\n        utils.publicSearchIndexerToGeneratedSearchIndexer(indexer),\n        {\n          ...updatedOptions,\n          ifMatch: etag,\n        }\n      );\n      return utils.generatedSearchIndexerToPublicSearchIndexer(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new datasource or modifies an existing one.\n   * @param dataSourceConnection - The information describing the datasource to be created/updated.\n   * @param options - Additional optional arguments.\n   */\n  public async createOrUpdateDataSourceConnection(\n    dataSourceConnection: SearchIndexerDataSourceConnection,\n    options: CreateorUpdateDataSourceConnectionOptions = {}\n  ): Promise<SearchIndexerDataSourceConnection> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-createOrUpdateDataSourceConnection\",\n      options\n    );\n    try {\n      const etag = options.onlyIfUnchanged ? dataSourceConnection.etag : undefined;\n\n      const result = await this.client.dataSources.createOrUpdate(\n        dataSourceConnection.name,\n        utils.publicDataSourceToGeneratedDataSource(dataSourceConnection),\n        {\n          ...updatedOptions,\n          ifMatch: etag,\n        }\n      );\n      return utils.generatedDataSourceToPublicDataSource(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new Skillset or modifies an existing one.\n   * @param skillset - The information describing the index to be created.\n   * @param options - Additional optional arguments.\n   */\n  public async createOrUpdateSkillset(\n    skillset: SearchIndexerSkillset,\n    options: CreateOrUpdateSkillsetOptions = {}\n  ): Promise<SearchIndexerSkillset> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-createOrUpdateSkillset\",\n      options\n    );\n    try {\n      const etag = options.onlyIfUnchanged ? skillset.etag : undefined;\n\n      const result = await this.client.skillsets.createOrUpdate(\n        skillset.name,\n        utils.publicSkillsetToGeneratedSkillset(skillset),\n        {\n          ...updatedOptions,\n          ifMatch: etag,\n        }\n      );\n\n      return utils.generatedSkillsetToPublicSkillset(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes an existing indexer.\n   * @param indexer - Indexer/Name of the indexer to delete.\n   * @param options - Additional optional arguments.\n   */\n  public async deleteIndexer(\n    indexer: string | SearchIndexer,\n    options: DeleteIndexerOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-deleteIndexer\", options);\n    try {\n      const indexerName: string = typeof indexer === \"string\" ? indexer : indexer.name;\n      const etag =\n        typeof indexer === \"string\"\n          ? undefined\n          : options.onlyIfUnchanged\n          ? indexer.etag\n          : undefined;\n\n      await this.client.indexers.delete(indexerName, {\n        ...updatedOptions,\n        ifMatch: etag,\n      });\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes an existing datasource.\n   * @param dataSource - Datasource/Name of the datasource to delete.\n   * @param options - Additional optional arguments.\n   */\n  public async deleteDataSourceConnection(\n    dataSourceConnection: string | SearchIndexerDataSourceConnection,\n    options: DeleteDataSourceConnectionOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexerClient-deleteDataSourceConnection\",\n      options\n    );\n    try {\n      const dataSourceConnectionName: string =\n        typeof dataSourceConnection === \"string\" ? dataSourceConnection : dataSourceConnection.name;\n      const etag =\n        typeof dataSourceConnection === \"string\"\n          ? undefined\n          : options.onlyIfUnchanged\n          ? dataSourceConnection.etag\n          : undefined;\n\n      await this.client.dataSources.delete(dataSourceConnectionName, {\n        ...updatedOptions,\n        ifMatch: etag,\n      });\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes an existing Skillset.\n   * @param skillset - Skillset/Name of the Skillset to delete.\n   * @param options - Additional optional arguments.\n   */\n  public async deleteSkillset(\n    skillset: string | SearchIndexerSkillset,\n    options: DeleteSkillsetOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-deleteSkillset\", options);\n    try {\n      const skillsetName: string = typeof skillset === \"string\" ? skillset : skillset.name;\n      const etag =\n        typeof skillset === \"string\"\n          ? undefined\n          : options.onlyIfUnchanged\n          ? skillset.etag\n          : undefined;\n\n      await this.client.skillsets.delete(skillsetName, {\n        ...updatedOptions,\n        ifMatch: etag,\n      });\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the current status and execution history of an indexer.\n   * @param indexerName - The name of the indexer.\n   * @param options - Additional optional arguments.\n   */\n  public async getIndexerStatus(\n    indexerName: string,\n    options: GetIndexerStatusOptions = {}\n  ): Promise<SearchIndexerStatus> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-getIndexerStatus\", options);\n    try {\n      const result = await this.client.indexers.getStatus(indexerName, updatedOptions);\n      return result;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Resets the change tracking state associated with an indexer.\n   * @param indexerName - The name of the indexer to reset.\n   * @param options - Additional optional arguments.\n   */\n  public async resetIndexer(indexerName: string, options: ResetIndexerOptions = {}): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-resetIndexer\", options);\n    try {\n      await this.client.indexers.reset(indexerName, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Runs an indexer on-demand.\n   * @param indexerName - The name of the indexer to run.\n   * @param options - Additional optional arguments.\n   */\n  public async runIndexer(indexerName: string, options: RunIndexerOptions = {}): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexerClient-runIndexer\", options);\n    try {\n      await this.client.indexers.run(indexerName, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}