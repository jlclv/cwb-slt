{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __rest } from \"tslib\";\n/// <reference lib=\"esnext.asynciterable\" />\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { SearchServiceClient as GeneratedClient } from \"./generated/service/searchServiceClient\";\nimport { logger } from \"./logger\";\nimport { createSearchApiKeyCredentialPolicy } from \"./searchApiKeyCredentialPolicy\";\nimport * as utils from \"./serviceUtils\";\nimport { createSpan } from \"./tracing\";\nimport { createOdataMetadataPolicy } from \"./odataMetadataPolicy\";\nimport { SearchClient } from \"./searchClient\";\nimport { KnownSearchAudience } from \"./searchAudience\";\n/**\n * Class to perform operations to manage\n * (create, update, list/delete)\n * indexes, & synonymmaps.\n */\nexport class SearchIndexClient {\n  /**\n   * Creates an instance of SearchIndexClient.\n   *\n   * Example usage:\n   * ```ts\n   * const { SearchIndexClient, AzureKeyCredential } = require(\"@azure/search-documents\");\n   *\n   * const client = new SearchIndexClient(\n   *   \"<endpoint>\",\n   *   new AzureKeyCredential(\"<Admin Key>\");\n   * );\n   * ```\n   * @param endpoint - The endpoint of the search service\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Search Index client.\n   */\n  constructor(endpoint, credential, options = {}) {\n    var _a, _b;\n    /**\n     * The API version to use when communicating with the service.\n     */\n    this.serviceVersion = utils.defaultServiceVersion;\n    /**\n     * The API version to use when communicating with the service.\n     * @deprecated use {@Link serviceVersion} instead\n     */\n    this.apiVersion = utils.defaultServiceVersion;\n    this.endpoint = endpoint;\n    this.credential = credential;\n    this.options = options;\n    const internalClientPipelineOptions = Object.assign(Object.assign({}, this.options), {\n      loggingOptions: {\n        logger: logger.info,\n        additionalAllowedHeaderNames: [\"elapsed-time\", \"Location\", \"OData-MaxVersion\", \"OData-Version\", \"Prefer\", \"throttle-reason\"]\n      }\n    });\n    this.serviceVersion = (_b = (_a = this.options.serviceVersion) !== null && _a !== void 0 ? _a : this.options.apiVersion) !== null && _b !== void 0 ? _b : utils.defaultServiceVersion;\n    this.apiVersion = this.serviceVersion;\n    this.client = new GeneratedClient(this.endpoint, this.serviceVersion, internalClientPipelineOptions);\n    if (isTokenCredential(credential)) {\n      const scope = this.options.audience ? `${this.options.audience}/.default` : `${KnownSearchAudience.AzurePublicCloud}/.default`;\n      this.client.pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential,\n        scopes: scope\n      }));\n    } else {\n      this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));\n    }\n    this.client.pipeline.addPolicy(createOdataMetadataPolicy(\"minimal\"));\n  }\n  listIndexesPage(options = {}) {\n    return __asyncGenerator(this, arguments, function* listIndexesPage_1() {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"SearchIndexClient-listIndexesPage\", options);\n      try {\n        const result = yield __await(this.client.indexes.list(updatedOptions));\n        const mapped = result.indexes.map(utils.generatedIndexToPublicIndex);\n        yield yield __await(mapped);\n      } catch (e) {\n        span.setStatus({\n          status: \"error\",\n          error: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    });\n  }\n  listIndexesAll(options = {}) {\n    return __asyncGenerator(this, arguments, function* listIndexesAll_1() {\n      var _a, e_1, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listIndexesPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Retrieves a list of existing indexes in the service.\n   * @param options - Options to the list index operation.\n   */\n  listIndexes(options = {}) {\n    const iter = this.listIndexesAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: () => {\n        return this.listIndexesPage(options);\n      }\n    };\n  }\n  listIndexesNamesPage(options = {}) {\n    return __asyncGenerator(this, arguments, function* listIndexesNamesPage_1() {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"SearchIndexClient-listIndexesNamesPage\", options);\n      try {\n        const result = yield __await(this.client.indexes.list(Object.assign(Object.assign({}, updatedOptions), {\n          select: \"name\"\n        })));\n        const mapped = result.indexes.map(idx => idx.name);\n        yield yield __await(mapped);\n      } catch (e) {\n        span.setStatus({\n          status: \"error\",\n          error: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    });\n  }\n  listIndexesNamesAll(options = {}) {\n    return __asyncGenerator(this, arguments, function* listIndexesNamesAll_1() {\n      var _a, e_2, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listIndexesNamesPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Retrieves a list of names of existing indexes in the service.\n   * @param options - Options to the list index operation.\n   */\n  listIndexesNames(options = {}) {\n    const iter = this.listIndexesNamesAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: () => {\n        return this.listIndexesNamesPage(options);\n      }\n    };\n  }\n  /**\n   * Retrieves a list of existing SynonymMaps in the service.\n   * @param options - Options to the list SynonymMaps operation.\n   */\n  async listSynonymMaps(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-listSynonymMaps\", options);\n    try {\n      const result = await this.client.synonymMaps.list(updatedOptions);\n      return result.synonymMaps.map(utils.generatedSynonymMapToPublicSynonymMap);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves a list of names of existing SynonymMaps in the service.\n   * @param options - Options to the list SynonymMaps operation.\n   */\n  async listSynonymMapsNames(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-listSynonymMapsNames\", options);\n    try {\n      const result = await this.client.synonymMaps.list(Object.assign(Object.assign({}, updatedOptions), {\n        select: \"name\"\n      }));\n      return result.synonymMaps.map(sm => sm.name);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves information about an index.\n   * @param indexName - The name of the index.\n   * @param options - Additional optional arguments.\n   */\n  async getIndex(indexName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-getIndex\", options);\n    try {\n      const result = await this.client.indexes.get(indexName, updatedOptions);\n      return utils.generatedIndexToPublicIndex(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves information about a SynonymMap.\n   * @param synonymMapName - The name of the SynonymMap.\n   * @param options - Additional optional arguments.\n   */\n  async getSynonymMap(synonymMapName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-getSynonymMaps\", options);\n    try {\n      const result = await this.client.synonymMaps.get(synonymMapName, updatedOptions);\n      return utils.generatedSynonymMapToPublicSynonymMap(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new index.\n   * @param index - The information describing the index to be created.\n   * @param options - Additional optional arguments.\n   */\n  async createIndex(index, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-createIndex\", options);\n    try {\n      const result = await this.client.indexes.create(utils.publicIndexToGeneratedIndex(index), updatedOptions);\n      return utils.generatedIndexToPublicIndex(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new SynonymMap in a search service.\n   * @param synonymMap - The synonymMap definition to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  async createSynonymMap(synonymMap, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-createSynonymMaps\", options);\n    try {\n      const result = await this.client.synonymMaps.create(utils.publicSynonymMapToGeneratedSynonymMap(synonymMap), updatedOptions);\n      return utils.generatedSynonymMapToPublicSynonymMap(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new index or modifies an existing one.\n   * @param index - The information describing the index to be created.\n   * @param options - Additional optional arguments.\n   */\n  async createOrUpdateIndex(index, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-createOrUpdateIndex\", options);\n    try {\n      const etag = options.onlyIfUnchanged ? index.etag : undefined;\n      const result = await this.client.indexes.createOrUpdate(index.name, utils.publicIndexToGeneratedIndex(index), Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n      return utils.generatedIndexToPublicIndex(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a new SynonymMap or modifies an existing one.\n   * @param synonymMap - The information describing the SynonymMap to be created.\n   * @param options - Additional optional arguments.\n   */\n  async createOrUpdateSynonymMap(synonymMap, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-createOrUpdateSynonymMap\", options);\n    try {\n      const etag = options.onlyIfUnchanged ? synonymMap.etag : undefined;\n      const result = await this.client.synonymMaps.createOrUpdate(synonymMap.name, utils.publicSynonymMapToGeneratedSynonymMap(synonymMap), Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n      return utils.generatedSynonymMapToPublicSynonymMap(result);\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes an existing index.\n   * @param indexName - Index/Name of the index to delete.\n   * @param options - Additional optional arguments.\n   */\n  async deleteIndex(index, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-deleteIndex\", options);\n    try {\n      const indexName = typeof index === \"string\" ? index : index.name;\n      const etag = typeof index === \"string\" ? undefined : options.onlyIfUnchanged ? index.etag : undefined;\n      await this.client.indexes.delete(indexName, Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes an existing SynonymMap.\n   * @param synonymMapName - SynonymMap/Name of the synonymMap to delete.\n   * @param options - Additional optional arguments.\n   */\n  async deleteSynonymMap(synonymMap, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-deleteSynonymMap\", options);\n    try {\n      const synonymMapName = typeof synonymMap === \"string\" ? synonymMap : synonymMap.name;\n      const etag = typeof synonymMap === \"string\" ? undefined : options.onlyIfUnchanged ? synonymMap.etag : undefined;\n      await this.client.synonymMaps.delete(synonymMapName, Object.assign(Object.assign({}, updatedOptions), {\n        ifMatch: etag\n      }));\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves statistics about an index, such as the count of documents and the size\n   * of index storage.\n   * @param indexName - The name of the index.\n   * @param options - Additional optional arguments.\n   */\n  async getIndexStatistics(indexName, options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-getIndexStatistics\", options);\n    try {\n      const result = await this.client.indexes.getStatistics(indexName, updatedOptions);\n      return result;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Calls an analyzer or tokenizer manually on provided text.\n   * @param indexName - The name of the index that contains the field to analyze\n   * @param text - The text to break into tokens.\n   * @param options - Additional arguments\n   */\n  async analyzeText(indexName, options) {\n    const {\n        abortSignal,\n        requestOptions,\n        tracingOptions,\n        analyzerName: analyzer,\n        tokenizerName: tokenizer\n      } = options,\n      restOptions = __rest(options, [\"abortSignal\", \"requestOptions\", \"tracingOptions\", \"analyzerName\", \"tokenizerName\"]);\n    const operationOptions = {\n      abortSignal,\n      requestOptions,\n      tracingOptions\n    };\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-analyzeText\", operationOptions);\n    try {\n      const result = await this.client.indexes.analyze(indexName, Object.assign(Object.assign({}, restOptions), {\n        analyzer,\n        tokenizer\n      }), updatedOptions);\n      return result;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves statistics about the service, such as the count of documents, index, etc.\n   * @param options - Additional optional arguments.\n   */\n  async getServiceStatistics(options = {}) {\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"SearchIndexClient-getServiceStatistics\", options);\n    try {\n      const result = await this.client.getServiceStatistics(updatedOptions);\n      return result;\n    } catch (e) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves the SearchClient corresponding to this SearchIndexClient\n   * @param indexName - Name of the index\n   * @param options - SearchClient Options\n   * @typeParam TModel - An optional type that represents the documents stored in\n   * the search index. For the best typing experience, all non-key fields should\n   * be marked optional and nullable, and the key property should have the\n   * non-nullable type `string`.\n   */\n  getSearchClient(indexName, options) {\n    return new SearchClient(this.endpoint, indexName, this.credential, options || this.options);\n  }\n}","map":{"version":3,"names":["isTokenCredential","bearerTokenAuthenticationPolicy","SearchServiceClient","GeneratedClient","logger","createSearchApiKeyCredentialPolicy","utils","createSpan","createOdataMetadataPolicy","SearchClient","KnownSearchAudience","SearchIndexClient","constructor","endpoint","credential","options","serviceVersion","defaultServiceVersion","apiVersion","internalClientPipelineOptions","Object","assign","loggingOptions","info","additionalAllowedHeaderNames","_b","_a","client","scope","audience","AzurePublicCloud","pipeline","addPolicy","scopes","listIndexesPage","span","updatedOptions","result","__await","indexes","list","mapped","map","generatedIndexToPublicIndex","e","setStatus","status","error","message","end","listIndexesAll","_d","_e","__asyncValues","_f","next","done","_c","value","page","__asyncDelegator","listIndexes","iter","Symbol","asyncIterator","byPage","listIndexesNamesPage","select","idx","name","listIndexesNamesAll","listIndexesNames","listSynonymMaps","synonymMaps","generatedSynonymMapToPublicSynonymMap","listSynonymMapsNames","sm","getIndex","indexName","get","getSynonymMap","synonymMapName","createIndex","index","create","publicIndexToGeneratedIndex","createSynonymMap","synonymMap","publicSynonymMapToGeneratedSynonymMap","createOrUpdateIndex","etag","onlyIfUnchanged","undefined","createOrUpdate","ifMatch","createOrUpdateSynonymMap","deleteIndex","delete","deleteSynonymMap","getIndexStatistics","getStatistics","analyzeText","abortSignal","requestOptions","tracingOptions","analyzerName","analyzer","tokenizerName","tokenizer","restOptions","__rest","operationOptions","analyze","getServiceStatistics","getSearchClient"],"sources":["C:\\Users\\julia\\Desktop\\cwb-slt\\search-website\\node_modules\\@azure\\search-documents\\src\\searchIndexClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { InternalClientPipelineOptions } from \"@azure/core-client\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { AnalyzeResult } from \"./generated/service/models\";\nimport { SearchServiceClient as GeneratedClient } from \"./generated/service/searchServiceClient\";\nimport { logger } from \"./logger\";\nimport { createSearchApiKeyCredentialPolicy } from \"./searchApiKeyCredentialPolicy\";\nimport {\n  AnalyzeTextOptions,\n  CreateIndexOptions,\n  CreateOrUpdateIndexOptions,\n  CreateOrUpdateSynonymMapOptions,\n  CreateSynonymMapOptions,\n  DeleteIndexOptions,\n  DeleteSynonymMapOptions,\n  GetIndexOptions,\n  GetIndexStatisticsOptions,\n  GetServiceStatisticsOptions,\n  GetSynonymMapsOptions,\n  IndexIterator,\n  IndexNameIterator,\n  ListIndexesOptions,\n  ListSynonymMapsOptions,\n  SearchIndex,\n  SearchIndexStatistics,\n  SearchServiceStatistics,\n  SynonymMap,\n} from \"./serviceModels\";\nimport * as utils from \"./serviceUtils\";\nimport { createSpan } from \"./tracing\";\nimport { createOdataMetadataPolicy } from \"./odataMetadataPolicy\";\nimport { SearchClientOptions as GetSearchClientOptions, SearchClient } from \"./searchClient\";\nimport { ExtendedCommonClientOptions } from \"@azure/core-http-compat\";\nimport { KnownSearchAudience } from \"./searchAudience\";\n\n/**\n * Client options used to configure Cognitive Search API requests.\n */\nexport interface SearchIndexClientOptions extends ExtendedCommonClientOptions {\n  /**\n   * The API version to use when communicating with the service.\n   * @deprecated use {@Link serviceVersion} instead\n   */\n  apiVersion?: string;\n\n  /**\n   * The service version to use when communicating with the service.\n   */\n  serviceVersion?: string;\n\n  /**\n   * The Audience to use for authentication with Azure Active Directory (AAD). The\n   * audience is not considered when using a shared key.\n   * {@link KnownSearchAudience} can be used interchangeably with audience\n   */\n  audience?: string;\n}\n\n/**\n * Class to perform operations to manage\n * (create, update, list/delete)\n * indexes, & synonymmaps.\n */\nexport class SearchIndexClient {\n  /**\n   * The API version to use when communicating with the service.\n   */\n  public readonly serviceVersion: string = utils.defaultServiceVersion;\n\n  /**\n   * The API version to use when communicating with the service.\n   * @deprecated use {@Link serviceVersion} instead\n   */\n  public readonly apiVersion: string = utils.defaultServiceVersion;\n\n  /**\n   * The endpoint of the search service\n   */\n  public readonly endpoint: string;\n\n  /**\n   * @internal\n   * @hidden\n   * A reference to the auto-generated SearchServiceClient\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Used to authenticate requests to the service.\n   */\n  private readonly credential: KeyCredential | TokenCredential;\n\n  /**\n   * Used to configure the Search Index client.\n   */\n  private readonly options: SearchIndexClientOptions;\n\n  /**\n   * Creates an instance of SearchIndexClient.\n   *\n   * Example usage:\n   * ```ts\n   * const { SearchIndexClient, AzureKeyCredential } = require(\"@azure/search-documents\");\n   *\n   * const client = new SearchIndexClient(\n   *   \"<endpoint>\",\n   *   new AzureKeyCredential(\"<Admin Key>\");\n   * );\n   * ```\n   * @param endpoint - The endpoint of the search service\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the Search Index client.\n   */\n  constructor(\n    endpoint: string,\n    credential: KeyCredential | TokenCredential,\n    options: SearchIndexClientOptions = {}\n  ) {\n    this.endpoint = endpoint;\n    this.credential = credential;\n    this.options = options;\n\n    const internalClientPipelineOptions: InternalClientPipelineOptions = {\n      ...this.options,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          additionalAllowedHeaderNames: [\n            \"elapsed-time\",\n            \"Location\",\n            \"OData-MaxVersion\",\n            \"OData-Version\",\n            \"Prefer\",\n            \"throttle-reason\",\n          ],\n        },\n      },\n    };\n\n    this.serviceVersion =\n      this.options.serviceVersion ?? this.options.apiVersion ?? utils.defaultServiceVersion;\n    this.apiVersion = this.serviceVersion;\n\n    this.client = new GeneratedClient(\n      this.endpoint,\n      this.serviceVersion,\n      internalClientPipelineOptions\n    );\n\n    if (isTokenCredential(credential)) {\n      const scope: string = this.options.audience\n        ? `${this.options.audience}/.default`\n        : `${KnownSearchAudience.AzurePublicCloud}/.default`;\n\n      this.client.pipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({ credential, scopes: scope })\n      );\n    } else {\n      this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));\n    }\n\n    this.client.pipeline.addPolicy(createOdataMetadataPolicy(\"minimal\"));\n  }\n\n  private async *listIndexesPage(\n    options: ListIndexesOptions = {}\n  ): AsyncIterableIterator<SearchIndex[]> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-listIndexesPage\", options);\n    try {\n      const result = await this.client.indexes.list(updatedOptions);\n      const mapped = result.indexes.map(utils.generatedIndexToPublicIndex);\n      yield mapped;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listIndexesAll(\n    options: ListIndexesOptions = {}\n  ): AsyncIterableIterator<SearchIndex> {\n    for await (const page of this.listIndexesPage(options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Retrieves a list of existing indexes in the service.\n   * @param options - Options to the list index operation.\n   */\n  public listIndexes(options: ListIndexesOptions = {}): IndexIterator {\n    const iter = this.listIndexesAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: () => {\n        return this.listIndexesPage(options);\n      },\n    };\n  }\n\n  private async *listIndexesNamesPage(\n    options: ListIndexesOptions = {}\n  ): AsyncIterableIterator<string[]> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-listIndexesNamesPage\", options);\n    try {\n      const result = await this.client.indexes.list({\n        ...updatedOptions,\n        select: \"name\",\n      });\n      const mapped = result.indexes.map((idx) => idx.name);\n      yield mapped;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async *listIndexesNamesAll(\n    options: ListIndexesOptions = {}\n  ): AsyncIterableIterator<string> {\n    for await (const page of this.listIndexesNamesPage(options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Retrieves a list of names of existing indexes in the service.\n   * @param options - Options to the list index operation.\n   */\n  public listIndexesNames(options: ListIndexesOptions = {}): IndexNameIterator {\n    const iter = this.listIndexesNamesAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: () => {\n        return this.listIndexesNamesPage(options);\n      },\n    };\n  }\n\n  /**\n   * Retrieves a list of existing SynonymMaps in the service.\n   * @param options - Options to the list SynonymMaps operation.\n   */\n  public async listSynonymMaps(options: ListSynonymMapsOptions = {}): Promise<Array<SynonymMap>> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-listSynonymMaps\", options);\n    try {\n      const result = await this.client.synonymMaps.list(updatedOptions);\n      return result.synonymMaps.map(utils.generatedSynonymMapToPublicSynonymMap);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves a list of names of existing SynonymMaps in the service.\n   * @param options - Options to the list SynonymMaps operation.\n   */\n  public async listSynonymMapsNames(options: ListSynonymMapsOptions = {}): Promise<Array<string>> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-listSynonymMapsNames\", options);\n    try {\n      const result = await this.client.synonymMaps.list({\n        ...updatedOptions,\n        select: \"name\",\n      });\n      return result.synonymMaps.map((sm) => sm.name);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves information about an index.\n   * @param indexName - The name of the index.\n   * @param options - Additional optional arguments.\n   */\n  public async getIndex(indexName: string, options: GetIndexOptions = {}): Promise<SearchIndex> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-getIndex\", options);\n    try {\n      const result = await this.client.indexes.get(indexName, updatedOptions);\n      return utils.generatedIndexToPublicIndex(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves information about a SynonymMap.\n   * @param synonymMapName - The name of the SynonymMap.\n   * @param options - Additional optional arguments.\n   */\n  public async getSynonymMap(\n    synonymMapName: string,\n    options: GetSynonymMapsOptions = {}\n  ): Promise<SynonymMap> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-getSynonymMaps\", options);\n    try {\n      const result = await this.client.synonymMaps.get(synonymMapName, updatedOptions);\n      return utils.generatedSynonymMapToPublicSynonymMap(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new index.\n   * @param index - The information describing the index to be created.\n   * @param options - Additional optional arguments.\n   */\n  public async createIndex(\n    index: SearchIndex,\n    options: CreateIndexOptions = {}\n  ): Promise<SearchIndex> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-createIndex\", options);\n    try {\n      const result = await this.client.indexes.create(\n        utils.publicIndexToGeneratedIndex(index),\n        updatedOptions\n      );\n      return utils.generatedIndexToPublicIndex(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new SynonymMap in a search service.\n   * @param synonymMap - The synonymMap definition to create in a search service.\n   * @param options - Additional optional arguments.\n   */\n  public async createSynonymMap(\n    synonymMap: SynonymMap,\n    options: CreateSynonymMapOptions = {}\n  ): Promise<SynonymMap> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-createSynonymMaps\", options);\n    try {\n      const result = await this.client.synonymMaps.create(\n        utils.publicSynonymMapToGeneratedSynonymMap(synonymMap),\n        updatedOptions\n      );\n      return utils.generatedSynonymMapToPublicSynonymMap(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new index or modifies an existing one.\n   * @param index - The information describing the index to be created.\n   * @param options - Additional optional arguments.\n   */\n  public async createOrUpdateIndex(\n    index: SearchIndex,\n    options: CreateOrUpdateIndexOptions = {}\n  ): Promise<SearchIndex> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-createOrUpdateIndex\", options);\n    try {\n      const etag = options.onlyIfUnchanged ? index.etag : undefined;\n\n      const result = await this.client.indexes.createOrUpdate(\n        index.name,\n        utils.publicIndexToGeneratedIndex(index),\n        {\n          ...updatedOptions,\n          ifMatch: etag,\n        }\n      );\n      return utils.generatedIndexToPublicIndex(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new SynonymMap or modifies an existing one.\n   * @param synonymMap - The information describing the SynonymMap to be created.\n   * @param options - Additional optional arguments.\n   */\n  public async createOrUpdateSynonymMap(\n    synonymMap: SynonymMap,\n    options: CreateOrUpdateSynonymMapOptions = {}\n  ): Promise<SynonymMap> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexClient-createOrUpdateSynonymMap\",\n      options\n    );\n    try {\n      const etag = options.onlyIfUnchanged ? synonymMap.etag : undefined;\n\n      const result = await this.client.synonymMaps.createOrUpdate(\n        synonymMap.name,\n        utils.publicSynonymMapToGeneratedSynonymMap(synonymMap),\n        {\n          ...updatedOptions,\n          ifMatch: etag,\n        }\n      );\n      return utils.generatedSynonymMapToPublicSynonymMap(result);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes an existing index.\n   * @param indexName - Index/Name of the index to delete.\n   * @param options - Additional optional arguments.\n   */\n  public async deleteIndex(\n    index: string | SearchIndex,\n    options: DeleteIndexOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-deleteIndex\", options);\n    try {\n      const indexName: string = typeof index === \"string\" ? index : index.name;\n      const etag =\n        typeof index === \"string\" ? undefined : options.onlyIfUnchanged ? index.etag : undefined;\n\n      await this.client.indexes.delete(indexName, {\n        ...updatedOptions,\n        ifMatch: etag,\n      });\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes an existing SynonymMap.\n   * @param synonymMapName - SynonymMap/Name of the synonymMap to delete.\n   * @param options - Additional optional arguments.\n   */\n  public async deleteSynonymMap(\n    synonymMap: string | SynonymMap,\n    options: DeleteSynonymMapOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-deleteSynonymMap\", options);\n    try {\n      const synonymMapName: string = typeof synonymMap === \"string\" ? synonymMap : synonymMap.name;\n      const etag =\n        typeof synonymMap === \"string\"\n          ? undefined\n          : options.onlyIfUnchanged\n          ? synonymMap.etag\n          : undefined;\n\n      await this.client.synonymMaps.delete(synonymMapName, {\n        ...updatedOptions,\n        ifMatch: etag,\n      });\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves statistics about an index, such as the count of documents and the size\n   * of index storage.\n   * @param indexName - The name of the index.\n   * @param options - Additional optional arguments.\n   */\n  public async getIndexStatistics(\n    indexName: string,\n    options: GetIndexStatisticsOptions = {}\n  ): Promise<SearchIndexStatistics> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-getIndexStatistics\", options);\n    try {\n      const result = await this.client.indexes.getStatistics(indexName, updatedOptions);\n      return result;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Calls an analyzer or tokenizer manually on provided text.\n   * @param indexName - The name of the index that contains the field to analyze\n   * @param text - The text to break into tokens.\n   * @param options - Additional arguments\n   */\n  public async analyzeText(indexName: string, options: AnalyzeTextOptions): Promise<AnalyzeResult> {\n    const {\n      abortSignal,\n      requestOptions,\n      tracingOptions,\n      analyzerName: analyzer,\n      tokenizerName: tokenizer,\n      ...restOptions\n    } = options;\n\n    const operationOptions = {\n      abortSignal,\n      requestOptions,\n      tracingOptions,\n    };\n\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-analyzeText\", operationOptions);\n\n    try {\n      const result = await this.client.indexes.analyze(\n        indexName,\n        { ...restOptions, analyzer, tokenizer },\n        updatedOptions\n      );\n      return result;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves statistics about the service, such as the count of documents, index, etc.\n   * @param options - Additional optional arguments.\n   */\n  public async getServiceStatistics(\n    options: GetServiceStatisticsOptions = {}\n  ): Promise<SearchServiceStatistics> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexClient-getServiceStatistics\", options);\n    try {\n      const result = await this.client.getServiceStatistics(updatedOptions);\n      return result;\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves the SearchClient corresponding to this SearchIndexClient\n   * @param indexName - Name of the index\n   * @param options - SearchClient Options\n   * @typeParam TModel - An optional type that represents the documents stored in\n   * the search index. For the best typing experience, all non-key fields should\n   * be marked optional and nullable, and the key property should have the\n   * non-nullable type `string`.\n   */\n  public getSearchClient<TModel extends object>(\n    indexName: string,\n    options?: GetSearchClientOptions\n  ): SearchClient<TModel> {\n    return new SearchClient<TModel>(\n      this.endpoint,\n      indexName,\n      this.credential,\n      options || this.options\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}