{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTracingClient } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options = {}) {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request, next) {\n      var _a, _b;\n      if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {\n        return next(request);\n      }\n      const {\n        span,\n        tracingContext\n      } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    }\n  };\n}\nfunction tryCreateTracingClient() {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION\n    });\n  } catch (e) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\nfunction tryCreateSpan(tracingClient, request, userAgent) {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(`HTTP ${request.method}`, {\n      tracingOptions: request.tracingOptions\n    }, {\n      spanKind: \"client\",\n      spanAttributes: {\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      }\n    });\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n    // set headers\n    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return {\n      span,\n      tracingContext: updatedOptions.tracingOptions.tracingContext\n    };\n  } catch (e) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\nfunction tryProcessError(span, error) {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\nfunction tryProcessResponse(span, response) {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\"\n    });\n    span.end();\n  } catch (e) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}","map":{"version":3,"names":["createTracingClient","SDK_VERSION","getUserAgentValue","logger","getErrorMessage","isError","isRestError","tracingPolicyName","tracingPolicy","options","userAgent","userAgentPrefix","tracingClient","tryCreateTracingClient","name","sendRequest","request","next","_a","tracingOptions","tracingContext","span","_b","tryCreateSpan","response","withContext","tryProcessResponse","err","tryProcessError","namespace","packageName","packageVersion","e","warning","undefined","updatedOptions","startSpan","method","spanKind","spanAttributes","url","requestId","isRecording","end","setAttribute","headers","createRequestHeaders","key","value","Object","entries","set","error","setStatus","status","statusCode","serviceRequestId","get"],"sources":["C:\\Users\\julia\\Desktop\\cwb-slt\\search-website\\node_modules\\@azure\\core-rest-pipeline\\src\\policies\\tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  type TracingClient,\n  type TracingContext,\n  type TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient || !request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, userAgent) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  userAgent?: string,\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes: {\n          \"http.method\": request.method,\n          \"http.url\": request.url,\n          requestId: request.requestId,\n        },\n      },\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext,\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\",\n    });\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}